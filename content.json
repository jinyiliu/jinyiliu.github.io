{"posts":[{"title":"CMB Power Spectra","text":"这是偏数学的背景辐射功率谱介绍，参考 Tojeiro 2006 和 Bartlett 2001 文章，最早是 Bond &amp; Efstathiou 1987 这篇文章提出的。 Definition因为微波背景辐射是各向同性的，以温度扰动为例，所以不同方向处的温度扰动可以写成下面这样的形式 \\[\\color{black}\\begin{aligned}C(\\bm{n},\\bm{n}^\\prime)&amp;=\\langle T(\\bm{n})T(\\bm{n}^\\prime) \\rangle_\\mathrm{ens}=C(\\theta)\\\\ &amp;=\\frac{1}{4\\pi}\\sum_\\ell (2\\ell+1)C_\\ell P_\\ell(\\cos\\theta)=\\sum_{\\ell m}C_\\ell Y_{\\ell m}^*(\\bm{n})Y_{\\ell m}(\\bm{n}^\\prime)\\end{aligned}\\] 其中 \\(\\bm{n}\\cdot\\bm{n}^\\prime=\\cos\\theta\\)，将 \\(T(\\bm{n})\\) 球谐展开，可以得到 \\[\\color{black}C_\\ell=\\langle a_{\\ell m}^* a_{\\ell m}^{} \\rangle_\\mathrm{ens}\\] Scaling\\[\\color{black}D_\\ell=\\frac{\\ell(\\ell+1)}{2\\pi}C_\\ell\\] This is useful for two reasons: it is logarithmic average of \\(D_\\ell\\) that gives the variance of the data and (therefore) for scale-invariant theories of structure formation, \\(D_\\ell\\) is roughly constant at large scales. Bond, Jaffle & Knox 1998Estimating the Power Spectrum of the CMB Cosmic Variance我们实际只能观测到一张天图，也就是一个随机实现，所以我们能够得到的功率谱实际上是 \\[\\color{black}\\hat{C}_\\ell=\\frac{1}{2\\ell+1}\\sum_m a_{\\ell m}^* a_{\\ell m}^{}\\] 所以这会天然地引入误差。 Phase在从天图提取功率谱的同时，我们会丢失相位信息。","link":"/2021/11/29/CMB-Power-Spetra/"},{"title":"Calibration in Radio","text":"Calibration 觉得这个报告讲得不是很清晰详细，只弄明白了皮毛。 The calibration in this lecture deals primarily with correcting the (baseline-based) visibilities for antenna-based effects. Solving for CalibrationWe have an imperfect visibility measurment per antenna pair: \\[\\color{black}V_{ij}^\\mathrm{obs}(u,v)=J_iJ_j^*V_{ij}^\\mathrm{true}(u,v)\\] The desired visibilieis were corrupted by the factor \\(\\color{black}J_iJ_j^*\\). To address all the effects more accurately, we can decompose \\(\\color{black}J_i\\) into separate components. F = ionospheric effectsT = tropospheric effectsP = parallactic angleE = antenna voltage pattern and gain curveG = electronic gainK = geometryX = Pol Angle – linear polarization position angleD = Pol Leakage – polarization leakageB = Bandpass – bandpass response Some of these effects may not be so important in your observation. For example if you are observing at high radio frequencies, then ionospheric effects are negligible because they only becomes domianted at lower frequencies (&lt;5GHz). And polarization calibration may not be not important in your data reduction if the intensity distribution is the only thing you care about. And some of these effects can be derived using external information, the observatory will provide you like F, T, P, E and parts of G, K. But there are still some left which we need to rely on observing calibrator sources. NOTE that here the effects we are talking about is mainly direction independent which is to say the corruption factor \\(\\color{black}J_i(t)\\) is only a function of time for each antenna and frequency channel. However, direction dependent calibration \\(\\color{black}J_i(t,l,m)\\) should be taken into account when it comes to wide field imaging. Advanced Techniques Make use of ancillary hardware when available Self calibration Baseline-based calibration Direction dependent calibration Observaing Calibrator Sources Flux density: standard candle with known structure and SED.Delay &amp; Bandpass: very bright and preferably unresolved source.Gain: bright and preferably unresolved source with accurate position. Ideally very close to the traget source and observe before and after the traget source. Pol Angle: polarized source with full Stokes model.Pol Leakage: unpolarized and preferably unresolved.","link":"/2022/11/12/Calibration-in-Radio/"},{"title":"Foregrounds in CMB physics","text":"前景最关键的地方在于给不同类型的前景建模，找到和观测最符合的SED（Spectral Energy Distribution），这样才能在多频段观测的 CMB 实验中进行精确的 component seperation 过程。 Overview SynchrotronAST9240 - Synchrotron Emission Start with Single particel to ensemble相对论性电子在磁场中的运动方程是 \\[\\frac{\\mathrm{d}}{\\mathrm{d}t}(\\gamma m_e \\bm{v})=\\frac{e}{c}(\\bm{v}\\times \\bm{B}) \\] 磁场不做功，所以有 \\[\\frac{\\mathrm{d}}{\\mathrm{d}t}(\\gamma m_e c^2)=0 \\\\ \\frac{\\mathrm{d}\\gamma}{\\mathrm{d}t}=0 \\] 之前的运动方程变成 \\[ \\gamma m_e\\frac{\\mathrm{d}\\bm{v}}{\\mathrm{d}t}=\\frac{e}{c}(\\bm{v}\\times\\bm{B}) \\] 将速度分解为平行于磁场的方向和垂直于磁场的方向，的到两个方程 \\[\\frac{\\mathrm{d}\\bm{v}_\\parallel}{\\mathrm{d}t}=0 \\\\ \\frac{\\mathrm{d}\\bm{v}_\\bot}{\\mathrm{d}t}=\\frac{e}{\\gamma m_e c}\\bm{v}_\\bot\\times\\bm{B} \\] 垂直于磁场方向的运动就是匀速圆周运动。可以的到同步辐射的示意图 Gyration frequency \\[ \\omega=\\frac{eB}{\\gamma m_e c} \\] Power emitted \\[ P=\\frac{2e^2\\gamma^4\\omega^2 v^2_\\bot}{3c^2} \\] 在非相对论的情况下（cyclotron radiation），观测者在任何一个角度看到的磁场频率都是 \\(\\omega\\)，观测者看到的频谱在 \\(\\omega\\)处有一个非常尖锐的峰值。但是在非相对论的情况下，因为存在集束效应（beamming effect），频谱会拓宽一些。 可以证明在频率 \\(\\omega\\) 处辐射功率是 \\[ P(\\omega)=\\frac{\\sqrt{3}}{2\\pi}\\frac{e^3B\\sin\\alpha}{m_e c^2}F\\left(\\frac{\\omega}{\\omega_c}\\right) \\] 其中 \\[ \\omega_c=\\frac{3\\gamma^2 eB\\sin\\alpha}{2m_e c} \\] 假设电子的能量分布符合幂律分布 \\[ N(\\gamma)\\mathrm{d}\\gamma=N_0\\gamma^{-p}\\mathrm{d}\\gamma \\] 那么 \\[ P(\\omega)\\propto \\int_{\\gamma_1}^{\\gamma_2} F\\left(\\frac{\\omega}{\\omega_c} \\right)\\gamma^{-p} \\mathrm{d}\\gamma \\] 下面把 \\(x=\\omega/\\omega_c\\) \\[ P(\\omega)\\propto \\omega^{-(p-1)/2} \\int_{x_1}^{x_2} F(x)x^{(p-3)/2}\\mathrm{d}x \\] 只要积分区间足够大，上面就可以简化为 \\[ \\color{blue}{ P(\\omega)\\propto\\omega^{-(p-1)/2} } \\] 可以看出同步辐射的SED只依赖于电子能量分布。在有更强的磁场的地方，电子的能量更高，但是这不会改变同步辐射能谱的形状。我们现在的观测有 \\(p=3\\) 左右。 Polarization同步辐射的光子中是偏振光子的百分率是 \\[ \\Pi=\\frac{p+1}{p+7/3} \\] 对于 \\(p=3\\) 的情况，有75%的同步辐射光子都是偏振的。 Faraday Rotation同步辐射建模的其中一个困难在于法拉第旋转，尤其在低频。 Data Halsam S-PASS C-BASS QUIJOTE Spetral Index Variantions在不同区域，电子能量分布的谱指数 \\(p\\)是不一样的。 Synchrotron-Dust Correlation同步辐射和尘埃分布会有一定相关性，但是因为同步辐射同时依赖于磁场强度以及宇宙线的分布，而尘埃是不依赖于磁场强度的，所以相关性不会特别强。 Thermal dustAST9240 - Dust Dust Specs Mainly composed of C, O, Mg, Si and Fe From 0.01-0.2 μm in size Absorbs starlight (UV), emits thermally (FIR) Typically ~1% of ISM mass Observables Extinction: the total extinction is significantly stronger than the polarized extinction Thermal Emission Dust PolarizationThe dust must be both aspherical and aligned (under magnetic field). The composition of dust grains are mostly carbonaceous and silicate in nature. Silicate features indicate robost polarization. Carbonaceous features notably lack polarization signatures. SED: Modified Blackbody Model (MBB)\\[ I_\\nu=A\\left(\\frac{\\nu}{\\nu_0}\\right)^\\beta B_\\nu(T_d) \\] where \\(A\\) is the amout of dust, \\(\\beta\\) represents dust composition, \\(T_d\\) is the dust temperature. Planck found that a single modified blackbody component is adequate for describing the emission thoughout the planck data. Meisner and Finkbeiner (2014) prefers two components. 除了尘埃颗粒组分上的差别会影响到SED建模的难度，尘埃的空间分布也会影响。 SED Variations and DecorrelationSED建模还有一些其它困难，比如 Dust SED may vary along the line of sight Decorrelation is a problem in polarization. Line of sight changes in magnetic field directions can enhance SED variations. 第二个没听明白。 HI Dust Correlations Free-Free在HII区域，电子经过带正电的离子或质子时，受到加速而产生的辐射。轫制辐射本身并不是偏振的，但是在HII区域可能会发生汤姆逊散射从而导致光子的偏振，如果我们有足够高的分辨率在HII区域是可以看到偏振光子的，但是现有的分辨率不够高，所以一般在偏振实验中不考虑轫制辐射。 CIBCIB是河外一些正在形成恒星的星系辐射的，不同频段之间的CIB并没有什么相关性，所以从CMB中提取CIB信息是一件没那么容易的事情。一般而言可以利用HI来扣除银河系尘埃对CIB的污染。 COCO分子在115GHz、230GHz、345GHz有发射线，在一些特定的区域比如大麦和小麦，有大约1%的偏振。CO会产生大约在 \\(r\\lesssim0.02\\) 的地方产生B模式偏振。 AMEAST9240 - Anomalous Microwave Emission (AME) 一个电偶极子或磁偶极子在旋转的时候会发出辐射。AME（Anomalous Microwave Emission）现阶段认为是极其小（小于1纳米）的尘埃颗粒在几十GHz上的自旋造成的，这样的辐射来源称为旋转的灰尘（spinning dust）。 Zodiacal EmissionAST9240 - Zodiacal Emission 上面的图片是可见光波段内太阳系内的尘埃反射太阳光而形成的，这本身不会对CMB实验产生影响，但是这些尘埃被太阳光加热而释放出FIR波段的热辐射会对CMB实验，尤其是高频波段产生干扰。 Zodiacal emission is spatial dependent. 黄道辐射和空间位置是相关的，所以最后观测到的黄道辐射和具体的巡天策略有关，不同的实验是不一样的。Planck实验中黄道辐射在857GHz频段最明显，但是对于现阶段的阿里实验，我猜想应该不太需要考虑来自黄道的辐射。 There is no universal template for zodiacal emission. We need to make custom maps for each dataset. To produce such maps, we need A model of the interplanetary dust Perform line-of-sight integrals for each observation Planck 2013 results. XIV. Zodiacal Emission","link":"/2021/10/19/Foregrounds-in-CMB-physics/"},{"title":"Hexo备忘录","text":"hexo clean # clean static fileshexo g -w # generate static fileshexo s # hexo serverhexo s --draft # hexo server with draftshexo d # hexo deployhexo new post &quot;blog title&quot;hexo new draft &quot;blog title&quot;hexo publish draft &quot;title&quot; 如果出现本地显示正常，远程服务器显示不正常的现象，请尝试清除浏览器缓存。 在 Mac Safari 上清除浏览器缓存，Settings -&gt; Privacy -&gt; Manage Website Data 清除所需要的网页的数据。","link":"/2022/04/13/Hexo%E5%A4%87%E5%BF%98%E5%BD%95/"},{"title":"ICARUS博客写作备忘录","text":"CodeThis is a code block. test.pyGitHubimport numpy as npdata = np.random.normal(10)print(data) Include code like this, this is a part of code sinx.f90: DO WHILE Loopview raw123456do while((abs(term)&gt;err) .and. (k&lt;=max_terms)) term=-term*x*x/(2*k*(2*k+1)) k=k+1 sin_=sin_+term print *,k,sin_end do KaTeXThis is an inline expression \\(a=b+c\\). This is a block expression. \\[F(x)=\\int_{-\\infty}^\\infty f(x)\\mathrm{d}x \\\\ f(x)=F^\\prime(x) \\] Use \\begin{aligned} and \\end{aligned} instead of \\begin{split} and \\end{split}. Use \\\\\\ instead of \\\\ to indicate a new line in the expression. ImageThis is an asset image. QuoteThis is a quote. 在我的后园，可以看见墙外有两株树，一株是枣树，还有一株也是枣树。 鲁迅 HTMLThis is a blank line. This is colored text. Info Box 文章内容有误？ OthersMail to me liujy0129@gmail.com. Jump to Code.","link":"/2021/10/07/ICARUS%E5%8D%9A%E5%AE%A2%E5%86%99%E4%BD%9C%E5%A4%87%E5%BF%98%E5%BD%95/"},{"title":"Imaging and Mosaicking","text":"Imaging Basics Mosaicking 每一次重温傅里叶变换都有新的认识！ An offset in one domain is a phase shift in the other. \\(\\color{black}F(x)\\) and \\(\\color{black}\\tilde{F}(k)\\) are Fourier pairs then \\[\\color{black}F(x-x_0)=\\tilde{F}(k)e^{i2\\pi x_0k}\\] 换句话说，源的位置移动反应在傅里叶空间是一个相位的变化，也就是相位决定了位置。 If we have now the calibrated visibilities, we can analyze the visibilities directly by model fitting on condition that the source has simple structures. Or to choose to recover an image from incomplete, nosiy samples of visibilities. Imaging Dirty Beam &amp; Dirty ImagesVisibilities data \\(\\color{black}V(u,v)\\) is actually sampled by \\[\\color{black}S(u,v)=\\sum_{k=1}^{M}\\delta(u-u_k,v-v_k)\\] The direct Fourier transform of visibilities is a dirty image \\[\\color{black}V(u,v)S(u,v)\\rightarrow T^D(l,m)\\] \\[\\color{black}T(l,m)*s(l,m)=T^D(l,m)\\] where the Fourier transform of the sampling pattern \\(\\color{black}s(l,m)\\rightarrow S(u,v)\\) is the point spread function or the synthesized beam. The dirty image is the true image convolved with the dirty beam. GriddingFFT is a must but it requires data on a regulary spaced grid. Conventional approach is to use convolution: \\[\\color{black}V^G(u,v) = V(u,v)S(u,v) * G(u,v) \\rightarrow T^D(l,m)g(l,m)\\] Now we can get our dirty image pretty fast. WeightingIntroduce weighting function \\(\\color{black}W(u,v)\\) into the gridding process, this modifies the sampling function as \\(\\color{black}S(u,v)W(u,v)\\) and changes the dirty beam shape \\(\\color{black}s(l,m)\\). CASA uses Robust (Briggs) weighting that can usually obtain most of the natural weight sensitivity at the same time as most of uniform weight resolution. The above sections will provide us dirty beam and dirty images. The next step is to clean the dirty images. DeconvolutionUse non-linear techniques to interpolate/extrapolate \\(\\color{black}v(u,v)\\) samples into unsampled regions of \\(\\color{black}(u,v)\\) plane to find a plausible model of \\(\\color{black}T(l,m)\\). A prior assumption about \\(\\color{black}T(l,m)\\) is that it can be represented by point sources. The dominant deconvolution algorithm in radio astronomy is CLEAN. Classic Hogbom CLEAN algorithmSee Video Lecture 51:40 which has a vivid illustration. MosaickingPass.","link":"/2022/11/21/Imaging-and-Mosaicking/"},{"title":"Magnification Matrix","text":"对弱引力透镜效应中放大矩阵的介绍。 矩阵的特征值和特征向量矩阵乘法就是线性变换，它的作用是旋转和拉伸一个向量，特征向量和特征值的定义 \\[\\color{black} A\\boldsymbol{v}=\\lambda \\boldsymbol{v} \\] 这是一个苍白的定义，应当注重它的意义，将矩阵进行特征分解 \\[\\color{black} A=Q\\Lambda Q^{-1}\\] 其中 \\(\\color{black} \\Lambda\\) 是对角阵，其对角元素为对应的特征值，\\(\\color{black} Q\\) 矩阵的每一列是对应特征值的特征向量。下面我们以二维矩阵为例，选择单位特征向量，选取特殊的坐标系使得矩阵 \\(\\color{black}A\\) 的其中一个特征向量和坐标轴重合，那么矩阵 \\(\\color{black}A\\) 可以分解为 \\[\\color{black}A=\\begin{bmatrix} 1 &amp; \\cos\\theta \\\\ 0 &amp; \\sin\\theta \\end{bmatrix}\\begin{bmatrix} \\lambda_1 &amp; 0 \\\\ 0 &amp; \\lambda_2 \\end{bmatrix}\\begin{bmatrix} 1 &amp; -(\\tan\\theta)^{-1} \\\\ 0 &amp; (\\sin\\theta)^{-1} \\end{bmatrix}\\] \\(\\color{black}\\lambda_1\\) 和 \\(\\color{black}\\lambda_2\\) 这里我们设定都是正值，\\(\\color{black}\\theta\\) 是两个特征向量的夹角。接下来我将这个线性变换作用到任意一个向量上 \\[\\color{black}\\begin{bmatrix} x^\\prime \\\\ y^\\prime \\end{bmatrix}=\\begin{bmatrix} \\lambda_1 x + (\\lambda_2-\\lambda_1)(\\tan\\theta)^{-1}y \\\\ \\lambda_2 y \\end{bmatrix}\\] 通过计算 \\(\\color{black} x^\\prime/y^\\prime\\) 我们可以猜测它的方向变化 \\[\\color{black} \\displaystyle{\\frac{x^\\prime}{y^\\prime}={\\displaystyle{\\frac{\\lambda_1}{\\lambda_2}}\\frac{x}{y}+\\left(1-\\frac{\\lambda_1}{\\lambda_2}\\right)\\frac{\\cos\\theta}{\\sin\\theta} }} \\] 到这里还看不太出来，我们可以通过反复作用这个线性变换来看看所作用的向量的方向的变化，在作用 \\(\\color{black}n\\) 次之后，向量方向变化为 \\[\\color{black} \\frac{x^{(n)}}{y^{(n)}}=\\left(\\frac{\\lambda_1}{\\lambda_2}\\right)^n \\frac{x}{y}+\\sum_{i=1}^{n}\\left(\\frac{\\lambda_1}{\\lambda_2}\\right)^{n-1} \\left(1-\\frac{\\lambda_1}{\\lambda_2}\\right)\\frac{\\cos\\theta}{\\sin\\theta} \\] 当 \\(\\color{black} \\lambda_1 &lt; \\lambda_2\\) 的时候，上式第一项趋于零，利用第二项和伯努利分布的相似性，我们可以知道第二项趋于 \\(\\color{black} \\cos\\theta/\\sin\\theta\\)，因此在多次重复作用该线性变换之后，向量的方向会趋于 \\(\\color{black}\\lambda_2\\) 所对应的特征向量的方向。 \\[\\color{black}\\lim_{n \\to \\infty}\\sum_{i=1}^{n}\\left(\\frac{\\lambda_1}{\\lambda_2}\\right)^{n-1} \\left(1-\\frac{\\lambda_1}{\\lambda_2}\\right) = 1\\] 因为我们总是可以选取一个坐标系使得其较大的特征值所对应的特征向量和坐标轴重合，所以如果 \\(\\color{black}\\lambda_1&gt;\\lambda_2\\)，那么该向量将向 \\(\\color{black}\\lambda_1\\) 所对应的特征向量上偏折。 而向量的长度，只有当主要的特征值 \\(\\color{black}\\lambda_1=1\\) 而另一个特征值 \\(\\color{black}\\lambda_2&lt;1\\) 的时候，在不断进行同一个线性变换的时候，向量最终会趋于稳定。如果两个特征值都大于一，那么最后向量会不断拉伸；都小于一，那么向量的长度被不断压缩。 test.pyimport numpy as npimport matplotlib.pyplot as plt# parameterstheta = 120 * np.pi / 180eigen_val = [1.1, 0.9]eigen_vec = np.array([(1., 0.), (np.cos(theta), np.sin(theta))]).TA = np.dot(eigen_vec, np.dot(np.diag(eigen_val), np.linalg.inv(eigen_vec)))vec = np.array([[0.], [2.]])for _ in range(20): vec = np.hstack([vec, np.dot(A, vec[:,-1]).reshape((2,1))])# plotfig, ax = plt.subplots()ax.axhline(0., c='k')ax.axline((0,0), (np.cos(theta), np.sin(theta)), c='k')ax.plot(vec[0], vec[1], 'm.-.')ax.axis('equal')ax.grid('on')plt.show() 矩阵的特征分解可以应用于图像压缩以及机器学习中的特征提取等领域。也可以将线性变换理解为向量运动的加速度，改变了向量的方向和大小。 矩阵的行列式和迹「迹（trace）是矩阵在线性变换中留下的痕迹。」 矩阵的行列式和迹都是在相似变换下不变的量。矩阵的行列式和特征值的关系是 \\[\\color{black} \\mathrm{det}(A)=\\prod \\lambda_i \\] 它几何意义是体积的变化，在二维的情况下就是面积的变化，为证明它，我们考虑一个小的矢量面积元 \\(\\color{black}\\mathrm{d}S = |\\mathrm{d}\\boldsymbol{x}\\times\\mathrm{d}\\boldsymbol{y}| \\)，经过矩阵 \\(\\color{black}A\\) 的线性变换之后变为\\(\\color{black}\\mathrm{d}S^\\prime = |\\mathrm{d}\\boldsymbol{x}^\\prime\\times\\mathrm{d}\\boldsymbol{y}^\\prime| \\)，简单推导 \\[\\color{black} \\begin{aligned} \\mathrm{d}S^\\prime &amp;= |(A\\mathrm{d}\\boldsymbol{x})\\times(A\\mathrm{d}\\boldsymbol{y})| \\\\ &amp;= \\left| \\begin{bmatrix}A_{11}\\mathrm{d}x_1+A_{12}\\mathrm{d}x_2 \\\\ A_{21}\\mathrm{d}x_1+A_{22}\\mathrm{d}x_2 \\end{bmatrix} \\times\\begin{bmatrix}A_{11}\\mathrm{d}y_1+A_{12}\\mathrm{d}y_2 \\\\ A_{21}\\mathrm{d}y_1+A_{22}\\mathrm{d}y_2 \\end{bmatrix}\\right| \\\\ &amp;= |(A_{11}A_{22}-A_{12}A_{21})|\\cdot|\\mathrm{d}x_1\\mathrm{d}y_2-\\mathrm{d}x_2\\mathrm{d}y_1| \\\\ &amp;=|\\mathrm{det}(A)|\\cdot|\\mathrm{d}\\boldsymbol{x}\\times\\mathrm{d}\\boldsymbol{y}| \\\\ &amp;=|\\mathrm{det}(A)|\\mathrm{d}S \\end{aligned}\\] 下面考查一个特殊的矩阵 \\(\\color{black}A=I+P\\)，其中 \\(\\color{black}P\\) 是一个很小的扰动，即有 \\(\\color{black}P_{ij}\\ll1\\)，那么 \\[\\color{black}\\begin{aligned} \\mathrm{det}(A)&amp;=\\prod(1+P_{ii})+\\mathcal{O}(P_{ij}^2)\\\\ &amp;=1+\\mathrm{tr}(P)+\\mathcal{O}(P_{ij}^2)\\end{aligned}\\] Magnification MatrixUnder thin lens approximation, \\[\\color{black}A=\\begin{pmatrix} 1-\\partial_{11}\\varphi &amp; -\\partial_{12}\\varphi \\\\ -\\partial_{12}\\varphi &amp; 1-\\partial_{22}\\varphi \\end{pmatrix} \\] Manification matrix \\(\\color{black}A\\) is the mapping matrix from image to source \\(\\color{black}\\boldsymbol{\\beta}=A\\boldsymbol{\\theta}\\), the true position of the source is \\(\\color{black}\\boldsymbol{\\beta}\\). Define convergence and shear \\[\\color{black}\\begin{aligned} \\kappa&amp;=\\frac{1}{2}(\\partial_{11}\\varphi+\\partial_{22}\\varphi) \\\\ \\gamma_1 &amp;= \\frac{1}{2}(\\partial_{11}\\varphi - \\partial_{22}\\varphi) \\\\ \\gamma_2&amp;=\\partial_{12}\\varphi \\end{aligned}\\] Then the magnification matrix can be written as \\[\\color{black}A=\\begin{pmatrix} 1-\\kappa-\\gamma_1 &amp; -\\gamma_2 \\\\ -\\gamma_2 &amp; 1-\\kappa+\\gamma_1 \\end{pmatrix} \\] The very first information about the matrix is the magnification of the image \\[\\color{black}\\mu=\\mathrm{det}(A^{-1})=\\frac{1}{\\mathrm{det}(A)}=\\frac{1}{(1-\\kappa)^2+|\\gamma|^2}\\approx 1+2\\kappa\\] where we have used the complex shear definition \\(\\color{black}\\gamma=\\gamma_1+i\\gamma_2\\). Then we can derive the eigenvalues of matrix \\(\\color{black}A\\). \\[\\color{black}\\lambda=1-\\kappa\\pm|\\gamma|\\] The inverse of the magnificaion matrix is a mapping from source to image \\[\\color{black}A^{-1}=\\mu\\begin{pmatrix} 1-\\kappa+\\gamma_1 &amp; \\gamma_2 \\\\ \\gamma_2 &amp; 1-\\kappa-\\gamma_1 \\end{pmatrix} \\] The corresponding eigenvalues are the inverse of eigenvalues of matrix \\(\\color{black}A\\). \\[\\color{black}\\lambda=\\frac{1}{1-\\kappa\\pm|\\gamma|}\\] The direction angles of the eigenvectors are \\[\\color{black}\\tan\\alpha=\\frac{\\gamma_2}{\\gamma_1\\mp|\\gamma|}=\\frac{-\\gamma_1\\mp|\\gamma|}{\\gamma_2}\\] Then if \\(\\color{black}\\gamma_1=0\\), the \\(\\color{black}\\alpha=\\pm\\pi/2\\), and this means the image will be elongated along one of these two directions. And if \\(\\color{black}\\gamma_2=0\\), we have \\(\\color{black}\\alpha=0\\) or \\(\\color{black}\\pi/2\\). In both cases, the two eigenvectors are perpendicular to each other and this is not the special case. One can prove that the eigenvectors of magnification matrix \\(\\color{black}A\\) are always perpendicular to each other. Or we can think of this in another way. Complex shear is spin-2 field and can thus be denoted as \\(\\color{black}\\gamma=|\\gamma|e^{i2\\alpha}\\), called position angle. And you can easily prove that \\(\\tan\\alpha\\) satisfies the above equation. Shear effect on Gaussian sourceOne sourceI will use astropy.model.Gaussian2D (which has the position angle as input parameter) as the galaxy brightness profile and show the shear effect. One would expect a \\(\\gamma=0.1\\) shear effect from a galaxy cluster. The source code to generate the above figures. test.pyimport numpy as npfrom time import timefrom astropy.modeling import modelsimport astropy.units as u# scipy.interp2d is deprecatedfrom scipy.interpolate import LinearNDInterpolatorimport matplotlib.pyplot as pltimshape = (300, 300)x_mean = imshape[1]//2y_mean = imshape[0]//2x, y = np.indices(imshape)x -= x_mean # To keep the image galaxy in the center of fieldy -= y_meanpixlen = 0.03 # in arcsec# Source galaxy shape informationx_stddev = 3.0 / 2.355 / pixleny_stddev = 2.0 / 2.355 / pixlentheta = np.pi - 30. * np.pi / 180.model = models.Gaussian2D(x_stddev=x_stddev, y_stddev=y_stddev, theta=theta)source = model(x, y)# Lensing Jacobin from source to imageA_g1_I = np.array(np.matrix([[1.-0.1, 0.0], [0.0, 1.+0.1]]).I)A_g2_I = np.array(np.matrix([[1., -0.1], [-0.1, 1.]]).I)# Imagedef lens(source, A_I): A_I_x, A_I_y = np.dot(A_I, np.vstack([x.flatten(), y.flatten()])) image_interp = LinearNDInterpolator((A_I_x, A_I_y), source.flatten(), fill_value=0.) image = image_interp(x.T, y.T) return imageimage_g1 = lens(source, A_g1_I)image_g2 = lens(source, A_g2_I)# Plotplt.style.use('classic')fig, ax = plt.subplots(nrows=1, ncols=3)ax[0].imshow(source, cmap='gray_r', origin='lower')ax[1].imshow(image_g1, cmap='gray_r', origin='lower')ax[2].imshow(image_g2, cmap='gray_r', origin='lower')ax[1].set_xlabel('$\\gamma_1=0.1$', fontsize=14)ax[2].set_xlabel('$\\gamma_2=0.1$', fontsize=14)for ax_i in ax: ax_i.set_xticks([]) ax_i.set_yticks([])plt.tight_layout()plt.show() One hundred sources Here is the source code still using astropy.models.Gaussian2D. One can also use GalSim package to do this. test.pyimport numpy as npfrom time import timefrom astropy.modeling import modelsimport astropy.units as ufrom scipy.interpolate import LinearNDInterpolatorimport matplotlib.pyplot as pltimshape = (300, 300)pixlen = 0.3 # in arcsec# Source modelsrng = np.random.default_rng(1997)nsrc = 100model_params = [ dict(amplitude=rng.uniform(.5, 1), x_mean=rng.uniform(0, imshape[1] - 1), y_mean=rng.uniform(0, imshape[0] - 1), x_stddev=rng.uniform(1./2.355/pixlen, 4./2.355/pixlen), y_stddev=rng.uniform(1./2.355/pixlen, 4./2.355/pixlen), theta=rng.uniform(0, np.pi)) for _ in range(nsrc)]model_list = [models.Gaussian2D(**kwargs) for kwargs in model_params]source = np.zeros(imshape)for model in model_list: model.render(source)# Imagedef lens(source, A_I): A_I_x, A_I_y = np.dot(A_I, np.vstack([x.flatten(), y.flatten()])) image_interp = LinearNDInterpolator((A_I_x, A_I_y), source.flatten(),fill_value=0.) image = image_interp(x.T, y.T) return imageimage = np.zeros(imshape)for model in model_list: # wait for a few minutes here x, y = np.indices(imshape) source_gal = model(x, y) # Ignore the position shift caused by lensing x, y = x - model.x_mean, y - model.y_mean image_gal = lens(source_gal, A_I) image += image_gal# Save for further analysisnp.savetxt('source.txt', source)np.savetxt('image.txt', image)# Plotplt.style.use('classic')fig, ax = plt.subplots(nrows=1, ncols=2)ax[0].imshow(source, cmap='gray_r', origin='lower')ax[1].imshow(image, cmap='gray_r', origin='lower')ax[1].set_xlabel('$\\gamma_1=0.1$', fontsize=14)for ax_i in ax: ax_i.set_xticks([]) ax_i.set_yticks([])plt.tight_layout()plt.show() Fourier TransformMy personal interest. Take the source and image data in one hundred sources case we have saved above, Fourier transform that. Not all Fourier transforms of images are meaningful. CMB is pure random field so its Fourier transforms are random fields as well and retain all the good statistical properties. In the case of galaxies, the coords are random, the source shapes are random, and it seems like adding them together would lead to something meaningless. 周期性的数据更适合傅里叶分析，并不是所有数据都适合傅里叶分析。","link":"/2023/02/14/Magnification-Matrix/"},{"title":"Neovim安装和配置","text":"使用 Neovim 作为我的编辑器。这个文章迁移自语雀，当时写得比较混乱。 Installation为了使用最新的功能，使用的是v0.6.0的Pre-release版本。 Vim-plug在 ~/.config/nvim/init.vim 中配置Neovim，这里只记录插件配置。我用Vim-plug管理插件，安装Vim-plug在指定目录下面 sh -c 'curl -fLo &quot;${XDG_DATA_HOME:-$HOME/.config}&quot;/nvim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim' 一般而言，用 lua 写的插件比vimscript效率高一些。这是我的配置文件https://github.com/jinyiliu/.config/blob/master/nvim/init.vim joshdick/onedark.vimOnedark配色方案，有配套的iTerm2的配色以及lightline和airline的配色方案。 itchyny/lightline.vim在对比多个不同的状态栏之后我选择了这个，因为这个非常轻量和简单 let g:lightline = { \\ 'colorscheme': 'onedark', \\ }let g:lightline.tabline = { \\ 'left': [ [ 'tabs' ] ], \\ 'right': [ ], \\ }let g:lightline.tab = { \\ 'active': [ 'filename', 'modified' ], \\ 'inactive': [ 'filename', 'modified' ], \\ }let g:lightline.seperator = { 'left': '', 'right': '' }let g:lightline.subseparator = { 'left': '', 'right': '' }let g:lightline.enable = { \\ 'statusline': 1, \\ 'tabline': 1 \\ } RRethy/vim-iluminate高亮当前指针所在的word，好用，速度也很快。 let g:Illuminate_ftblacklist = [ 'nerdtree' ]let g:Illuminate_delay = 0hi link illuminatedWord Visual airblace/vim-gitgutter一个增强git的显示功能的插件，无脑装。 LunarWatcher/auto-pairsA maintained fork of jiangmiao/auto-pairs. tpopt/vim-commentary众多注释插件中这个最好用。 nvim-telescope/telescope.nvim这是一个文件搜索的插件，之前有用过传统的nerdtree，不是很好用，后来出了新的fzf（Fuzzy Finder）因为有模糊搜索使文件导航变得容易一些，telescope是最新的文件导航插件，界面简洁好看。注意下面几个插件都要装 Plug 'nvim-lua/popup.nvim'Plug 'nvim-lua/plenary.nvim'Plug 'nvim-telescope/telescope.nvim'Plug 'nvim-telescope/telescope-fzy-native.nvim' 还有一些其它的nvim-telescope出品的插件比如telescope_frecency.nvim等，但它们不是很重要。这样配置一下 local actions = require('telescope.actions')require('telescope').setup { defaults = { entry_prefix = &quot; &quot;, prompt_prefix = &quot;► &quot;, selection_caret = &quot;► &quot;, initial_mode = &quot;insert&quot;, sorting_strategy = &quot;descending&quot;, layout_strategy = &quot;horizontal&quot;, winblend = 10, set_env = { ['COLORTERM'] = 'truecolor' }, color_devicons = true, border = {}, borderchars = { '─', '│', '─', '│', '╭', '╮', '╯', '╰' }, path_display = {}, file_previewer = require'telescope.previewers'.vim_buffer_cat.new, grep_previewer = require'telescope.previewers'.vim_buffer_vimgrep.new, qflist_previewer = require'telescope.previewers'.vim_buffer_qflist.new, buffer_previewer_maker = require'telescope.previewers'.buffer_previewer_maker, file_sorter = require('telescope.sorters').get_fuzzy_file, file_ignore_patterns = {}, generic_sorter = require'telescope.sorters'.get_generic_fuzzy_sorter, mappings = { i = { [&quot;&lt;C-j&gt;&quot;] = actions.move_selection_next, [&quot;&lt;C-k&gt;&quot;] = actions.move_selection_previous, }, }, }} neoclide/coc.nvimNeovim内置的LSP（Language Server Protocal）还不是特别完善，先用着CoC，虽然总有一天内置LSP会超过。用来做代码补全。 可以输入:checkhealth provider来查看一些依赖是否正确安装，我只需要python3 provider就可以了（使用pip安装）。 coc-pyrightcoc-python 因为不再进行维护，所以官方建议coc-pyright和 coc-jedi 进行python语言的诊断。pyright是微软开发的，jedi依赖环境（需要用conda安装jedi的环境），所以还是用coc-pyright比较好。但是微软最近开发了一个更快的linter和补全插件叫pylance，收费使用，仅VScode用户可以用。 但是存在一个不是很美观的地方 去掉这些需要到.config/nvim/plugged/coc.nvim/autoload/coc/float.vim把这一行修改了（对应函数create_cursor_float） let width = dimension['width']- let lines = map(a:lines, {_, s -&gt; s =~# '^—' ? repeat('—', width) : s})+ let lines = map(a:lines, {_, s -&gt; s =~# '^—' ? repeat(' ', width) : s}) let config = extend({'lines': lines, 'relative': 'cursor'}, a:config) let config = extend(config, dimension) coc-jsonJSON插件，偶尔需要用它。 coc-vimlspVim脚本语言的language server工具。 coc-shBash language server工具，但是装的时候有一些问题，所以一般不会装这个。 🗑 Other plugs没有在使用，但是将来可能用到的插件。 RRethy/vim-hexokinase这个是显示颜色的一个插件，依赖Go语言，前端码农应该很需要。 set termguicolorslet g:Hexokinase_highlighters = [ 'backgroundfull' ] nvim-treesitter/nvim-treesitter语法高亮的插件。安装完成之后需要安装对应的语言包，我的默认配置 lua &lt;&lt; EOFrequire'nvim-treesitter.configs'.setup { ensure_installed = { &quot;bash&quot;, &quot;c&quot;, &quot;c_sharp&quot;, &quot;cpp&quot;, &quot;fortran&quot;, &quot;python&quot;, &quot;json&quot;, &quot;html&quot;, &quot;latex&quot;, &quot;lua&quot; }, highlight = { enable = true, disable = { &quot;python&quot;, &quot;c&quot; }, },}EOF 实际效果确实 python 高亮更花里胡哨了，但是整体视觉体验并没有提升，所以我虽然加载了这个插件，但其实并没有用。 easymotion/vim-easymotion其中就两个字母的搜索比较常用（easymotion-s2） nmap ss &lt;Plug&gt;(easymotion-s2)let g:EasyMotion_smartcase = 1 但还有一个影响颜值的问题，不过无所谓，这个插件没有也可以，不是特别影响码代码的效率。","link":"/2020/07/08/Neovim%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/"},{"title":"Spherical Harmonics","text":"Definition参考 Spherical Harmonics USCS Physics 116C Fall 2012 的第一部分来推导拉普拉斯方程在球坐标下的解，并由此引入球谐函数 \\[\\color{black}Y_{\\ell}^{m}(\\theta, \\phi)=(-1)^{m} \\sqrt{\\frac{(2 \\ell+1)}{4 \\pi} \\frac{(\\ell-m) !}{(\\ell+m) !}} P_{\\ell}^{m}(\\cos \\theta) e^{i m \\phi} \\] 下面是一个来显示不同球谐函数的脚本 import numpy as npimport matplotlib.pyplot as pltfrom scipy.special import sph_harmfrom matplotlib import cmtheta, phi = np.meshgrid(np.linspace(0, np.pi, 1000), np.linspace(0, np.pi*2, 1000))x, y, z = np.array([np.sin(theta) * np.sin(phi), np.sin(theta) * np.cos(phi), np.cos(theta)])cmap = cm.ScalarMappable(cmap=plt.get_cmap('bwr'))def show_sph_harm(l, m): plt.figure() ax = plt.gca(projection='3d') sph = sph_harm(m, l, phi, theta) ax.plot_surface(x, y, z, facecolors=cmap.to_rgba(sph.real)) ax.set_axis_off() plt.show() 由球谐函数的正交完备性，我们可以将任意一个 \\(\\theta\\) 和 \\(\\phi\\) 的函数进行球谐展开 \\[f(\\theta, \\phi)=\\sum_{\\ell=0}^{\\infty} \\sum_{m=-\\ell}^{\\ell} a_{\\ell m} Y_{\\ell}^{m}(\\theta, \\phi) \\] Properties由勒让德多项式的定义，可以知道 \\[Y_{\\ell}^{-m}(\\theta, \\phi)=(-1)^{m} Y_{\\ell}^{m}(\\theta, \\phi)^{*} \\] Orthgonality \\[\\int Y_\\ell^m(\\theta,\\phi)Y_{\\ell^\\prime}^{m^\\prime}(\\theta,\\phi)^*\\mathrm{d}\\Omega=\\delta_{\\ell\\ell^\\prime}\\delta_{mm^\\prime}\\] Laplace \\[\\nabla^2 \\equiv\\frac{1}{\\sin ^{2} \\theta} \\frac{\\partial}{\\partial \\theta}\\left(\\sin \\theta \\frac{\\partial}{\\partial \\theta}\\right)+\\frac{1}{\\sin ^{2} \\theta} \\frac{\\partial^{2}}{\\partial \\phi^{2}}\\] \\[\\color{purple} \\nabla^2 Y_\\ell^m(\\theta,\\phi)=-\\ell(\\ell+1)Y_\\ell^m(\\theta,\\phi) \\] Addition Theorem \\[P_\\ell(\\bm{n}\\cdot\\bm{n}^\\prime)=\\frac{4\\pi}{2\\ell+1}\\sum_m Y_\\ell^m(\\bm{n})Y_\\ell^m(\\bm{n}^\\prime)^*\\] Flat Sky Approximation平天近似就是当天区足够小的时候，可以用傅立叶变换替代球谐变换 \\[\\sum_{\\ell m}T_{\\ell m}Y_\\ell^m(\\hat{\\bm n}) \\rightarrow \\sum_{\\bm{k}} T_\\bm{k}e^{i\\bm{k}\\cdot\\hat{\\bm{n}}}\\] 在球谐变换中，不同 \\(\\ell\\) 模式对应于不同尺度 \\[\\ell\\sim\\frac{\\pi}{\\theta}\\] 所以从球谐变换到傅立叶变换，存在这样的替换关系 \\[ l=2\\pi k \\] Flat_Sky_Approximation.ipynb","link":"/2021/11/19/Spherical-Harmonics/"},{"title":"Sampling Methods","text":"MCMC Interactive Gallary Gaussian SamplingAST9240 - Gaussian Sampling Multidimensional Gaussian\\[ \\bm{x}\\sim\\mathcal{N}(\\bm{\\mu}, C) \\] where \\(C\\) is covariance matrix \\[ C=\\langle \\bm{x}\\bm{x}^T\\rangle - \\langle\\bm{x}\\rangle\\langle\\bm{x}\\rangle^T \\] The log-likelihood is \\[ \\ln\\mathcal{L}(\\bm{x}|\\bm{\\mu})=\\mathrm{const.} - \\frac{1}{2}(\\bm{x}-\\bm{\\mu})^TC^{-1}(\\bm{x}-\\bm{\\mu}) \\] The sample of \\(\\bm\\mu\\) is \\[\\bm{\\mu}=\\bm{x}+C^{1/2}\\bm{\\eta} \\] \\(C^{1/2}\\bm{\\eta}\\) is flunctuation term, and \\(C^{1/2}\\) satisfies \\[C^{1/2}(C^{1/2})^T=C\\] d = As+nOften we have \\[\\color{red}\\bm{d}=A\\bm{s}+\\bm{n}\\] and covariance matrix of noise \\(\\bm n\\) \\[ \\langle\\bm{n}\\bm{n}^T\\rangle = N \\] Here \\(A\\) can be pointing matrix, mixing matrix, etc in different contexts. The log-likelihood is \\[\\ln P(\\bm{d}|\\bm{s}) = \\mathrm{const.} - \\frac{1}{2}(\\bm{d}-A\\bm{s})^TN^{-1}(\\bm{d}-A\\bm{s})\\] Take derivative of the likelihood and make it equal to zero \\[ \\begin{aligned} \\frac{\\mathrm{d}\\ln\\mathcal{L}(\\bm{d}|\\bm{s})}{\\mathrm{d}\\bm{s}}&amp;\\propto-\\frac{\\mathrm{d}}{\\mathrm{d}\\bm{s}}(\\bm{d}-A\\bm{s})^TN^{-1}(\\bm{d}-A\\bm{s}) \\\\ &amp;=A^TN^{-1}(\\bm{d}-A\\bm{s})+(\\bm{d}-A\\bm{s})^TN^{-1}A=0 \\end{aligned} \\] The two terms \\(A^TN^{-1}(\\bm{d}-A\\bm{s})\\) and \\((\\bm{d}-A\\bm{s})^TN^{-1}A\\) are equivalent, and we get the maximum likelihood solution \\[ \\bm{s}=(A^TN^{-1}A)^{-1}A^TN^{-1}\\bm{d} \\] 上面的求逆从数值上是非常困难的，所以我们经常写成下面这种形式 \\[\\color{red} (A^TN^{-1}A)\\bm{s}=A^TN^{-1}\\bm{d} \\] 这就是 \\(A\\bm{x}=\\bm{b}\\) 的形式，可以用 Conjugate Gradient 的方法来求解（可以看Painless conjugate gradient快速掌握 CG 算法）。到此为止，我们还差一个 flunctuation term，需要求 \\(\\bm{s}\\) 的协方差矩阵 \\[ \\langle\\bm{s}\\bm{s}\\rangle - \\langle\\bm{s}\\rangle\\langle\\bm{s}\\rangle^T =(A^TN^{-1}A)^{-1} \\] 实际上，上面这个操作把 \\(\\bm{n}\\) 的协方差矩阵转换到 \\(\\bm{s}\\) 的空间下。如果 \\(\\bm{d}\\) 是 TOD 数据，\\(\\bm{s}\\) 是一张天图，\\(A\\) 是 mapmaking 的操作，那么这就是把协方差矩阵从时间带到像素空间中，相当于误差传递的过程。 The sample is \\[ \\bm{s}=(A^TN^{-1}A)^{-1}A^TN^{-1}\\bm{d}+A^TN^{1/2}\\bm{\\eta} \\] With a prior on sIf the prior is gaussian, then \\[\\ln P(\\bm{d}|\\bm{s}) = \\mathrm{const.} - \\frac{1}{2}(\\bm{d}-A\\bm{s})^TN^{-1}(\\bm{d}-A\\bm{s}) - \\frac{1}{2}(\\bm{s}-\\bm{\\mu}_s)^TS^{-1}(\\bm{s}-\\bm{\\mu}_s)\\] The sample becomes \\[ (A^TN^{-1}A+S^{-1})\\bm{s}=A^TN^{-1}\\bm{d}+S^{-1}\\bm{\\mu}_s+A^TN^{1/2}\\bm{\\eta}_1+S^{1/2}\\bm{\\eta}_2 \\] The covariance matrix of \\(\\bm{s}\\) is \\[ \\langle\\bm{s}\\bm{s}\\rangle - \\langle\\bm{s}\\rangle\\langle\\bm{s}\\rangle^T =(A^TN^{-1}A+S^{-1})^{-1} \\] 在前景分析中，各种前景成分的 amplitude 可以采用 Gaussian sampling 的方法，因为 amplitude 和数据的关系是线性的，如果噪声是高斯的，那么前景的 amplitude 也是高斯的。 Inversion samplingAST9240 - Inversion Sampling 在前景分析中，谱指数可以用 Inversion sampling 的方法，Inversion sampling 可以应用到任何概率分布上。 Metropolis samplingAST9240 - Monte Carlo sampling methods Metropolis-Hastings samplingAllows for asymmetric transition rules. Gibbs samplingBasis of Commander3. See Gibbs Sampling in MCMC Interactive Gallary. 我们本来需要计算 \\( P(h, g, s_\\mathrm{cmb}, b|\\bm{d}) \\)，采用 Gibbs 采样方法，我们只需要去计算 \\[\\begin{aligned} &amp;P(h|\\bm{d},g,s_\\mathrm{cmb},b) \\\\ &amp;P(g|\\bm{d}, h, s_\\mathrm{cmb}, b) \\\\ &amp;P(s_\\mathrm{cmb}|\\bm{d}, h, g, b) \\\\ &amp;P(b|\\bm{d}, h, g, s_\\mathrm{cmb}) \\end{aligned}\\] 而这些都是非常好计算的，甚至有一些有解析的形式。 Jinyi_gibbs_sampler","link":"/2021/11/08/Sampling-Methods/"},{"title":"Stokes Parameters","text":"在我学习微波背景辐射的早期，为了预防自己不停地温习斯托克斯参量的定义，写了这篇小记。 EM Radiation我们通常用电矢量代表电磁波。真空中电磁波的电场方程满足 \\[\\left( \\nabla^2-\\frac{1}{c^2}\\frac{\\partial^2}{\\partial t^2} \\right)\\vec{E}=0 \\] 其平面波解为 \\[\\vec{E}(\\vec{r},t)=\\vec{E}_0 e^{i(\\vec{k}\\cdot\\vec{r}-\\omega t+\\varphi)} \\] 这是一个数学解，只取实部作为物理解。有时常把常数相位因子 \\(e^{i\\varphi}\\) 并入振幅中，则 \\[\\vec{E}(\\vec{r},t)=\\vec{E}_0 e^{i(\\vec{k}\\cdot\\vec{r}-\\omega t)} \\] 注意，这个时候 \\(\\vec{E}_0\\) 已是复数。 Polarizaiton为了研究电磁波的偏振态，我们将电矢量分为两个分量 \\[ E_x=E_{0x}\\cos(kz-\\omega t +\\varphi_x)\\\\ E_y=E_{0y}\\cos(kz-\\omega t +\\varphi_y)\\] 这是一个用于展示电磁波偏振椭圆的脚本 import numpy as npimport matplotlib.pyplot as pltE0X = 1.0E0Y = 1.0PHIX = 0.0 * np.pi / 180PHIY = 45.0 * np.pi / 180OMEGAxT = np.linspace(0, 2*np.pi, 100)EX = E0X * np.cos(-OMEGAxT + PHIX)EY = E0Y * np.cos(-OMEGAxT + PHIY)fig, ax = plt.subplots()for EX_, EY_ in zip(EX, EY): ax.cla() ax.set_xlim([-1, 1]) ax.set_ylim([-1, 1]) ax.grid(zorder=0) ax.set_aspect('equal') ax.axvline(0, c='k') ax.axhline(0, c='k') ax.plot(EX, EY, c='lightgray', lw=7, zorder=1) ax.arrow(0, 0, EX_, EY_, fc='r', ec='r', width=0.02, length_includes_head=True, head_width=0.08, head_length=0.1, zorder=2) plt.pause(0.01) 上面所提到的电磁波平面解总是处于线偏振、圆偏振或者椭圆偏振中。在自然界中，电矢量可以朝着任意方向做运动。这些光的相位、偏振方向各不相同，呈现随机分布，所以我们看到的这些辐射的总和是没有特定偏振方向的，这就是自然光。 这里所讨论的都是标量偏振光，还有矢量偏振光，它在横截面上每一点的偏振状态都不一样，并不是均匀分布的。最典型的矢量偏振光是轴对称矢量光，它是 Helmholtz 方程在柱坐标下的特解。 Stokes Parameters下面是一个偏振椭圆 \\(\\chi=0\\) 表示线偏振，反之则表示椭圆偏振或圆偏振，\\(\\psi\\) 表示偏振的方向。斯托克斯参量分别为 \\[\\begin{aligned}I&amp;=I \\\\ Q&amp;=Ip\\cos2\\psi\\cos2\\chi \\\\ U&amp;=Ip\\sin2\\psi\\cos2\\chi \\\\ V&amp;=Ip\\sin2\\chi \\end{aligned}\\] 其中 \\(p\\) 表示偏振的程度 \\[ p=\\frac{\\sqrt{Q^2+U^2+V^2}}{I} \\] \\(I\\) 正比于入射光的总光强 \\(Q\\) 表征了光是更接近于 \\(x\\) 方向偏振（\\(Q&gt;0\\)）还是 \\(y\\) 方向偏振（\\(Q&lt;0\\)） \\(U\\) 表征了光是更接近于 \\(+45^\\circ\\) 方向偏振（\\(U&gt;0\\)）还是 \\(-45^\\circ\\) 方向偏振（\\(U&lt;0\\)） \\(V\\) 表征了光是更接近于右旋光偏振（\\(V&gt;0\\)）还是左旋光偏振（\\(V&lt;0\\)） 斯托克斯参量如此定义就是为了测量方便。关于具体如何测量参数的值，可以参考 「知乎」矢量偏振光简介。","link":"/2021/11/19/Stokes-Parameters/"},{"title":"Spin-weighted Spherical Harmonics","text":"参考 Grant Salton 论文 第二章和 Zaldarriaga &amp; Seljak 1997 的文章。因为斯托克斯参量中的 Q 和 U 场是依赖坐标系定义，普通的球谐变换处理之后的到的物理量也是依赖坐标系的，但是我们需要的物理量最好是不随坐标系变化的，所以需要引入特殊的球谐函数。 SpinDefinition: A spin-s function \\(_sf(\\theta, \\phi)\\) is one that, under a rotation of \\((\\bm{e}_1, \\bm{e}_2)\\) by an angle \\(\\psi\\) about \\(\\bm{n}\\), transforms via \\[_sf\\rightarrow e^{-is\\psi}{_s}f \\] Spin Raising and LoweringWe define the spin rasing operator \\(\\eth\\) and spin lowring operator \\(\\bar{\\eth}\\) \\[ \\eth=-(\\sin\\theta)^s\\left[ \\frac{\\partial}{\\partial\\theta}+\\frac{i}{\\sin\\theta}\\frac{\\partial}{\\partial\\phi} \\right](\\sin\\theta)^{-s} \\] \\[ \\bar{\\eth}=-(\\sin\\theta)^{-s}\\left[ \\frac{\\partial}{\\partial\\theta}-\\frac{i}{\\sin\\theta}\\frac{\\partial}{\\partial\\phi} \\right](\\sin\\theta)^s \\] The spin-weighted spherical harmonics are then defined as \\[ _sY_\\ell^m=\\sqrt{\\frac{(\\ell-s)!}{(\\ell+s)!}}\\eth^s Y_\\ell^m\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (0\\leq s\\leq\\ell) \\] \\[ _sY_\\ell^m=\\sqrt{\\frac{(\\ell+s)!}{(\\ell-s)!}}(-1)^s\\bar{\\eth}^{-s} Y_\\ell^m\\ \\ \\ \\ \\ (-\\ell\\leq s\\leq 0) \\] PropertiesThe spin-weighted harmonics satisfy orthogonality and completeness \\[\\int {_s}Y_{\\ell}^m(\\theta,\\phi) \\ {_s}Y_{\\ell^\\prime}^{m^\\prime}(\\theta,\\phi)^*\\mathrm{d}\\Omega = \\delta_{\\ell\\ell^\\prime} \\delta_{mm^\\prime} \\] \\[\\sum_{\\ell m} {_s}Y_{\\ell}^m(\\theta,\\phi)\\ {_s}Y_{\\ell}^{m}(\\theta^\\prime,\\phi^\\prime)^*=\\delta(\\cos\\theta-\\cos\\theta^\\prime)\\delta(\\phi-\\phi^\\prime) \\] Other important properties \\[ \\eth {_s}Y_\\ell^m=+\\sqrt{(\\ell-s)(\\ell+s+1)}\\ {_{s+1}}Y_\\ell^m \\] \\[ \\bar{\\eth} {_s}Y_\\ell^m=-\\sqrt{(\\ell+s)(\\ell-s+1)}\\ {_{s-1}}Y_\\ell^m \\] Stokes QU根据斯托克斯参量的定义 \\[\\begin{aligned}Q&amp;=Ip\\cos2\\psi\\cos2\\chi \\\\ U&amp;=Ip\\sin2\\psi\\cos2\\chi \\end{aligned}\\] 当我们旋转坐标系的时候，\\(\\chi\\) 并不发生变化，但是 \\(\\psi\\rightarrow\\psi+\\Delta\\)，我们得到一组新的斯托克斯参量值 \\[\\begin{aligned}Q^\\prime&amp;=Ip\\cos2\\psi^\\prime\\cos2\\chi \\\\ U^\\prime&amp;=Ip\\sin2\\psi^\\prime\\cos2\\chi \\end{aligned}\\] 我们构造一组量 \\(Q\\pm iU\\)，可以证明它们分别是自旋 \\(\\pm2\\) 的量，以 \\(Q+iU\\) 为例，令 \\(Ip=1\\) \\[\\begin{aligned}Q^\\prime+iU^\\prime&amp;=\\cos2\\psi^\\prime\\cos2\\chi+i\\sin2\\psi^\\prime\\cos2\\chi \\\\ &amp;=(\\cos2\\psi\\cos2\\Delta-\\sin2\\psi\\sin2\\Delta)\\cos2\\chi \\\\ &amp;\\ \\ \\ \\ \\ + i(\\sin2\\psi\\cos2\\Delta+\\cos2\\psi\\sin2\\Delta)\\cos2\\psi \\\\ &amp;=Q\\cos2\\Delta-U\\sin2\\Delta+i(U\\cos2\\Delta+Q\\sin2\\Delta) \\\\ &amp;=(Q+iU)(\\cos2\\Delta+i\\sin2\\Delta) \\\\ &amp;=(Q+iU)e^{i2\\Delta} \\end{aligned}\\] E and B modes把复数标量场 \\(Q\\pm iU\\) 按照自旋为 2 的球谐函数展开 \\[(Q\\pm iU)(\\theta,\\phi)=\\sum_{\\ell m} {_{\\pm2}}a_{\\ell m}\\ {_{\\pm2}}Y_\\ell^m(\\theta,\\phi)\\] 定义新的量，用来确定偏振的信息 \\[\\begin{aligned}a_{E,\\ell m}&amp;=-\\frac{1}{2}({_2}a_{\\ell m} + {_{-2}}a_{\\ell m}) \\\\ a_{B,\\ell m}&amp;=\\frac{i}{2}({_2}a_{\\ell m} - {_{-2}}a_{\\ell m})\\end{aligned}\\] 由这两个系数可以定义新的自旋为零的场 \\[\\begin{aligned} E(\\theta,\\phi)&amp;=\\sum_{\\ell m} a_{E,\\ell m}\\ Y_\\ell^m(\\theta,\\phi) \\\\ B(\\theta,\\phi)&amp;=\\sum_{\\ell m} a_{B,\\ell m}\\ Y_\\ell^m(\\theta,\\phi) \\end{aligned}\\] 可以看出 \\(EB\\) 场和 \\(QU\\) 场就是简单的导数的关系，通过自旋的升降把 \\(Q\\pm iU\\) 变为零自旋的场 \\[\\color{black}\\begin{aligned}E(\\theta,\\phi)&amp;=-\\frac{1}{2}\\Large{[}\\normalsize \\bar{\\eth}^2(Q+iU)+\\eth^2(Q-iU) \\Large{]}\\normalsize\\\\ B(\\theta,\\phi)&amp;=\\frac{i}{2}\\Large{[}\\normalsize \\bar{\\eth}^2(Q+iU)-\\eth^2(Q-iU) \\Large{]}\\end{aligned}\\] 出于兴趣，我尝试着画了一下它们的区别：可以明显看到它们之间的区别，\\(QU\\)有明显的纹路，是依赖坐标系的，而 \\(EB\\) 呈现的是各向同性的特征。","link":"/2021/11/19/Spin-weighted-Spherical-Harmonics/"},{"title":"Ubuntu配置FTP服务器","text":"用 vsftpd -v 查看是否安装了 vsftpd，如果没有，安装它 sudo apt-get install vsftpd 编辑 /etc/vsftpd.conf 配置文件 /etc/vsftpd.conf12345678910111213listen=NOlisten_ipv6=YESanonymous_enable=NOwrite_enable=YESdirmessage_enable=YESuse_localtime=YESxferlog_enable=YESconnect_from_port_20=YESsecure_chroot_dir=/var/run/vsftpd/emptypam_service_name=vsftpdrsa_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pemrsa_private_key_file=/etc/ssl/private/ssl-cert-snakeoil.keyssl_enable=NO 启动vsftpd应用新的更改 sudo systemctl start vsftpdsudo systemctl enable vsftpdsudo service vsftpd start 如果要用macOS访达的 ⌘K 连接服务器，需要关闭VPN。","link":"/2021/10/14/Ubuntu%E9%85%8D%E7%BD%AEFTP%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"title":"Units in CMB physics","text":"AST9240 - The Microwave Sky MJy/sr普朗克定律（Planck’s Law） \\[ B_{\\nu}=\\frac{2h\\nu^3}{c^2}\\frac{1}{\\mathrm{exp}(h{\\nu}/kT)-1} \\] \\(B_\\nu\\) 的单位是\\(\\mathrm{erg/s/sr/m^2/Hz}\\) ，但是在CMB物理中我们通常用的单位是Jansky，是\\(B_\\nu\\)对立体角 \\(\\Omega\\) 的积分 \\[ \\mathrm{1\\ Jy=10^{-23}\\ erg/s/m^2/Hz} \\] 上面图中，电磁波的频率单位换算是这样的 \\[ f\\mathrm{[GHz]} = 30\\times f\\mathrm{[cm^{-1}]} \\] \\(\\mathrm{KJy/sr}\\) 是前景分析中经常用到的单位。 KRJ瑞利-金斯定律（Rayleigh-Jeans Law）是黑体辐射的低频近似 \\[ B_\\nu\\approx\\frac{2\\nu^2 kT}{c^2} \\] 由这个近似我们可以定义瑞利-金斯温度（Rayleigh-Jeans Temperature） \\[ T_\\mathrm{RJ}\\equiv\\frac{I_\\nu c^2}{2\\nu^2 k} \\] 这样温度和辐射强度是一个简单的线性关系，给定一个天空中某一位置的辐射 \\(I_\\nu\\)，我们就可以的到它的温度，\\(\\mathrm{K_{RJ}}\\) 是在前景分析中经常用到的单位，在分析低频尘埃辐射的时候非常方便。 KCMB在实际做观测的时候，显然我们不可能对天空中每一个位置都测一遍黑体谱然后根据拟合确定它的温度。测量一个给定带宽下的全天辐射是效率更高的，类似于天文学里测光的概念，只不过在测光中我们最终想要的到的量是星等，在CMB测量中我们想要的量是温度。 这就需要找到 \\(\\Delta I_\\nu \\) 和 \\( \\Delta T_\\mathrm{CMB} \\) 之间的对应关系，因为扰动在 \\( 10^{-5} \\) 量级，只考虑到一阶 \\[ \\Delta I_\\nu=\\left(\\frac{\\partial B_\\nu}{\\partial T}\\right)_{T_\\mathrm{CMB}}\\Delta T =\\frac{2h\\nu^3}{c^2}\\frac{xe^x}{(e^x-1)^2}\\frac{\\Delta T_\\mathrm{CMB}}{T_\\mathrm{CMB}} \\] 其中 \\(x=h\\nu/kT_\\mathrm{CMB}\\)，这个单位的好处是所有频段都将的到同样的温度扰动 \\( \\Delta T_\\mathrm{CMB} \\)，但是因为 \\(e^x\\) 的存在，不适合高频CMB前景的分析。 KCMB to KRJ\\[\\begin{aligned} \\Delta T_\\mathrm{RJ}&amp;=\\frac{\\Delta I_\\nu c^2}{2\\nu^2k} = \\frac{2h\\nu^3}{c^2}\\frac{xe^x}{(e^x-1)^2}\\frac{\\Delta T_\\mathrm{CMB}}{T_\\mathrm{CMB}}\\frac{c^2}{2\\nu^2k}\\\\ &amp;= \\frac{h\\nu}{kT_\\mathrm{CMB}}\\frac{xe^x}{(e^x-1)^2}\\Delta T_\\mathrm{CMB} \\\\ &amp;=\\frac{x^2e^x}{(e^x-1)^2}\\Delta T_\\mathrm{CMB} \\end{aligned}\\] # ConstantskB = 1.38e-23 # Boltzmanns constantTcmb = 2.7255 # CMB temperatureh = 6.626e-34 # Plancks constant# Unit conversion between Rayleigh–Jeans units and cmb unitsdef Kcmb_to_Krj(nu): # nu in GHz x = h * nu * 1.0e9 / (kB * Tcmb) return x**2 * np.exp(x) / (np.exp(x) - 1.)**2","link":"/2021/10/18/Units-in-CMB-physics/"},{"title":"VLA Continuum Tutorial 3C391","text":"VLA Continuum Tutorial 3C391-CASA5.5.0 After flagging the data. Examining the data Below we can see the flagging process has taken effect. The phase \\(\\color{black}\\theta=2\\pi f \\bm{b}\\cdot\\bm{s}/c\\) is linearly dependent on frequency and the slope is \\(\\color{black}2\\pi\\bm{b}\\cdot\\bm{s}/c\\). If we set iteraxis=baseline in plotms function, by clicking on the green arrow Next button we can switch the plots between different baselines and we will see that different baselines have different slopes. Reference AntennaPhase solutions are typically referred to a specific antenna. Phase corresponds to position. What we need is actually to align all the source positions to one point and it doesn’t matter where the point is. Often we require the antenna be available over the entire observation. And in general, for calibration purposes, we would like to select an antenna that is close to the center of the array (but why?). Use plotant to show the antenna positions. We will use antenna ea21 as the ref antenna later on. Calibrating the DataThe calibration process in the tutorial is a bit different from the calibration lecture in the workshop. The observed visibility function is related to the true visibility by \\[\\color{black}V_{ij}^\\prime=b_{ij}(t)B_i(f,t)B_j^*(f,t)g_i(t)g_j(t)e^{i[\\theta_i(t)-\\theta_j(t)]}V_{ij}\\] In CASA the task gencal can specify calibration values of various types providing a means of antenna-based calibration values mannually. Antenna Position CorrectionsSpecify values for \\(\\color{black}b_{ij}(t)\\). Initial Flux Density ScalingUse task setjy to place the model visibility amplitude for the flux density calibrator 3C 286. By comparison with the observed data, determine the \\(\\color{black}g_i\\) values. Initial Phase CalibrationFirst we calculate the gain with task gaincal using all three calibrators to see if there are some bad data. Antennas other than ea05 look OK so we flag it from the data. And again this time we use gaincal to calculate the gain using only the bandpass calibrator. Still don’t completely understand this calibration step. Delay Calibration This step solves for the antenna-based delays (See Phase vs. Frequency plot above). Use gaincal with gaintype K to solve for the relative delay of each antenna relative to the reference antenna. 也就是说这里修正了不同天线的时间延迟，会让上面那一张 Phase vs. Frequency 的图里的曲线变成水平直线。 Bandpass Calibration The task bandpass calculates the amplitude and phase as a function of frequency for each spectral window containing more than on channel. Correspondes to the complex bandpass \\(\\color{black}B_i(f,t)\\). Gain CalibrationFirst, they use flux density calibrator 3C 286 to calculate the appropriate complex gains \\(\\color{black}g_i\\) and \\(\\color{black}\\theta_i\\). Second, to minimize the differences through the atmosphere between the lines of sight to the gain calibrator 3C 286 and the target source, we also need to establish relative gain amplitudes and phases for different antennas using phase calibrator. The appropriate complex gains for a direction on the sky close to the target source will be determined from the phase calibrator. 已经开始看不明白了，就不能多写一点公式嘛！ Scaling the Amplitude Gains我不理解。你为啥不理解？你要理解！真不理解。 Applying the CalibrationUse applycal to apply the calibration solutions to flux density calibrators J1331-3030(3C 286), visibility phase calibrator J1822-0938, target fields in the mosaic. Then we now have fully-calibrated visibilities in the CORRECTED-DATA column of the measurement set. Then split off the target fields by split to create a new, calibrated measurement set containing all the target fields. After that, run statwt task to correct the data weights in the measurement set based on the variance of data. 总而言之，校准完毕！ ImagingExamine the newly calibrated data. Imaging parametersIt is important to have an idea of what values to use for the image pixel (cell) size. The maximum baseline is about 16,000 wavelengths, i.e., the smallest angular scale of 12 arcseconds. The most effective cleaning occurs with at least 4-5 pixels across the synthesized beam. As such, we can chose the value of 2.5 arcseconds as the cell size. Set the image size = [480,480] in this case to fully cover the supernova remnant and also take into account of FFT efficiency. Multi-scale Mosaic CleanCan’t believe this is not done automatically. I have to open a graphic viewer and select some clean regions mannually at the start of clean algorithm iterations. Finally use viewer to show the cleaned image. In the DATA DISPLAY OPTIONS -&gt; BASIC SETTINGS, I set the colormap to Hot Metal 2 and Scaling Power Cycles to -0.5. Here is what I get Image AnalysisUse CASA to determine the peak brightness, flux density and image noise level. Didn’t do this.","link":"/2022/12/09/VLA-Continuum-Tutorial-3C391/"},{"title":"Note on Classical Mechanics by Leonard Susskind","text":"这是之前 Leonard Susskind 的 Classical Mechanics 课程所做的一些摘抄和笔记。他的这一系列课程做得非常好，把握住了物理学里最重要的一些概念。 Nature of laws of physicsThere are 2 varieties of questions in physics What are the specific laws for particular kinds of system? The particular system could be a planet moving in a field of a heavy mass that has it own particular laws which are different than an electric charged particle moving in the field of a magnet. What are the rules of allowable laws? This is a more general framework. The state of a system or the configuration consists of all the things that you need to know to predict the future. Classical physics doesn’t allow probability. However, why there is a probability in classical statiscal mechanics? We need to know 2 things to predict the future. One is the laws of physics, the other is initial conditions. The laws of physics in classical physics don’t have ambiguity in them (equations in Quantumn mechanics do have ambiguity), but there is always a degree of ambiguity in our knowledge of initial conditions. We can never know the initial conditions perfectly no matter how many decimal points we may have. The imperfect knowledge in initial conditions might lead to chaos. Classical mechanics are not only deterministic into the future but they are determinstic into the past which makes them reversible. Reversibility means that you can recoup the past as well as the future in the laws of physics. In other words, not all the configurations untimately run to the same final configuration and the initial distinctions get preserved in some form. So in this sense, Aristotle’s law, apart from being experimentally incorrect, is also irreversible \\[\\boldsymbol{F}=m\\boldsymbol{v}=m\\dot{\\boldsymbol{x}}=m\\frac{\\mathrm{d}\\boldsymbol{x}}{\\mathrm{d}t}\\] The above equation is not reversible in a sense that if we change the sign of the time. And this is not what happens with Newton’s equations. \\[\\boldsymbol{F}=m\\boldsymbol{a}=m\\frac{\\mathrm{d}^2\\boldsymbol{x}}{\\mathrm{d}t^2}\\] Newton’s lawsWe can think of Newton’s second law as 2 first-order equations for 2 separate variables \\[\\boldsymbol{F}=\\dot{\\boldsymbol{p}}\\\\ {\\boldsymbol{p}}=m\\dot{\\boldsymbol{x}}\\] The first equation tells us how momentum changes and the second tells us how positon changes. So the space of initial conditions is not as it was in Aristotle’s formulation — just the space of possible positions — is the space of positions and momentum which is called phase space. It’s just a convention to use momentum rather than velocity. Phase space is a very important concept in all of physics. The beauty of harmonic oscillator is a theory of phase space where the system simply executes circular motions in phase lengths of different radii corresponding to different energy. Newton’s first law is clearly redundant. It’s just a special case of second law. Newton’s third law is that \\(F_{ij}=-F_{ji}\\) along the line of center. Conservation of momentum and Conservation of energy for a closed system are direct results of Newton’s laws and they are more fundamental than Newton’s expression of his laws. We will see this more clearly later. There is a word for forces which are governed by potential energy — conservative forces — they are associated with energy conservation. \\[F_i=-\\frac{\\partial V(\\boldsymbol{x})}{\\partial x_i}\\] 在中文里，将conservative force翻译成保守力是否具有保证守恒的意思，但我依然认为这个翻译不是很直观，要不是当年查了保守力的英文，我都不知道为什么力也分保守的和开放的。 Principle of least actionThe principle of least action is a misnomer. The word that’s wrong is least. We should use stationary instead of least. The generic situation for stationary points is not that it’s a minimum or maximum but that it’s stationary in different directions e.g. Saddle points You are in equilibrium whenever you are at a point where the potential doesn’t change when you move a little bit \\(\\delta x\\) — of course this is true for first order in \\(\\delta x\\). \\[\\delta V(x)=\\frac{\\partial V(x)}{\\partial x}\\delta x=0\\] This is equivalent to \\(\\partial V(x)/\\partial x=0\\) . Of course we are interested in more complicated motions — we are interested not in finding stationary points that satisfy the equations of motion but whole trajectories. Trajectories are curves through space and time. The problem of finding functions which minimize some quantity is called calculus of variations e.g. the shortes line between two points on a curved space — geodesic and another example is Fermat’s principle of least time. The principle of least action is quite different from the previous Newton’s laws. In Newton’s equations of motion, the initial conditons are the initial position and the velocity of an object at a given time. However, in the principle of least action, the initial velocity is not the input but part of the solution. The only thing we know about the object is the initial and final positions, and we need to find a proper trajectory that fill in between the initial and final positions. Problems in classical mechanics are always to minimize (make stationary) something. \\[A=\\int_{t_0}^{t_1}\\mathrm{d}t\\ \\mathcal{L}(\\boldsymbol{x},\\dot{\\boldsymbol{x}})\\] And such problems can always be reduced to differential equations — Euler-Lagrange equations. \\[\\frac{\\mathrm{d}}{\\mathrm{d}t}\\frac{\\partial\\mathcal{L}}{\\partial\\dot{\\boldsymbol{x}}}=\\frac{\\partial\\mathcal{L}}{\\partial\\boldsymbol{x}}\\] Examples不能一口吃个胖子。为了从 Eular-Lagrange 方程中得到牛顿方程，拉氏量应当设为 \\[\\mathcal{L}=\\frac{m\\dot{\\boldsymbol{x}}^2}{2}-V(\\boldsymbol{x})\\] 利用拉格朗日量，我们可以很方便地将牛顿运动方程转化到任意坐标系的运动方程，这是因为最小作用量原理（Action principle）本身并不是坐标依赖的。当然这里 Susskind 举了个例子，也就是二维匀速旋转坐标系中的运动方程。另该二维坐标系在一个等势面上 \\(V=0\\) ，经过不复杂的计算，可以得到在二维匀速旋转坐标系中的拉氏量为 \\[\\mathcal{L}=\\frac{m}{2}(\\dot{x}^2+\\dot{y}^2)+\\frac{m\\omega^2}{2}(x^2+y^2)+m\\omega(\\dot{x}y-x\\dot{y})\\] 这其中 \\(m\\omega^2(x^2+y^2)/2\\) 表现得就仿佛是 potential field 一样，这是离心力（centrifugal force）的体现。最后一项是拉氏量中全新的一项，它与速度（velocity dependent）以及坐标线性相关，这就是科里奥利力（Coriolis force）的体现。上式拉氏量的 Eular-Lagrange 方程为 \\[m\\ddot{x}=m\\omega^2x-2m\\omega\\dot{y}\\\\ m\\ddot{y}=m\\omega^2y+2m\\omega\\dot{x}\\] 其中第二项就是科里奥利力 \\(\\boldsymbol{F}=2m\\boldsymbol{v}\\times\\boldsymbol{w}\\) ，所以科里奥利力与速度线性相关并且其方向总是垂直与速度，这一点和洛伦兹力（Lorentz force）\\(\\boldsymbol{F}=q\\boldsymbol{v}\\times\\boldsymbol{B}\\) 颇为相似。上面的例子是运动坐标系，坐标是时间依赖的。而下面这个例子是极坐标，如果势场之与 \\(r\\) 相关，那么拉氏量为 \\[\\mathcal{L}=\\frac{m}{2}(\\dot{r}^2+r^2\\dot{\\theta}^2)-V(r)\\] 那么Eular-Lagrange方程为 \\[m\\ddot{r}=mr\\dot{\\theta}^2-\\frac{\\mathrm{d}V}{\\mathrm{d}r}\\\\ \\frac{\\mathrm{d}}{\\mathrm{d}t}mr^2\\dot{\\theta}=0\\] 上面第二式说明 \\(mr^2\\dot{\\theta}=\\mathrm{const.}=L\\) 这个物理量是守恒的，而这个物理量守恒的根本原因在于 \\(V(r)\\) 并不依赖于 \\(\\theta\\) ，其实这并不是一个非常巧合的现象，这是一个非常普遍的规律：如果一个拉氏量不依赖于某一个坐标（通常称为 cyclic coordinate），那么就一定有一个对应的守恒律，更多内容参见 Conservation 这一部分。 我们可以发现 Eular-Lagrange 方程非常适合进行坐标变换，或者说 Eular-Lagrange 方程具有坐标不变形（invariant）。后来人们发现很多物理定律，比如麦克斯韦的电磁理论、相对论等都可以囊括进 Eular-Lagrange 方程中，因此 Eular-Lagrange 方程更像一个经验规律，而最小作用量原理是一个在所有物理规律之上的更为广泛的规律，并且目前还没有反例。甚至是在粒子物理的研究中，第一步就是写出粒子的拉氏量。 下面是粒子物理标准模型（Standard Model）的拉氏量 \\(\\mathcal{L}_{SM}\\) ，比较适合印在 T-shirt 上装逼。 Symmetry and Conservation无限小的量是这样的一个量，它并不是零，所以我们不可以忽略它，但它确实又非常小，所以我们可以忽略所有它的平方等等。从这一节开始教授引入了广义坐标的概念，Euler-Lagrange 方程为 \\[\\frac{\\mathrm{d}}{\\mathrm{d}t}\\frac{\\partial\\mathcal{L}}{\\partial\\dot{\\boldsymbol{q}}}=\\frac{\\partial\\mathcal{L}}{\\partial\\boldsymbol{q}}\\\\ \\frac{\\mathrm{d}}{\\mathrm{d}t}\\boldsymbol{p}=\\frac{\\partial\\mathcal{L}}{\\partial\\boldsymbol{q}}\\] 而 \\(\\boldsymbol{p}\\) 称为 \\(\\boldsymbol{q}\\) 的共轭动量（conjugate momentum），或者写成不同坐标分量的形式 \\(\\dot{p}_i=\\partial\\mathcal{L}/\\partial q_i\\) 亦可。 下面是一点守恒律的内容。考虑一个这样的系统，它的拉氏量如上，当 \\(a=1\\) 且 \\(b=-1\\) 的时候也就相当于系统的势能取决于 \\(q_1-q_2\\) 相对位置，这也是实际研究中很常见的情况。 \\[\\mathcal{L}=\\frac{q_1^2+q_2^2}{2}-V(aq_1+bq_2)\\] 经过不复杂的推导，有下面的守恒律存在 \\[\\frac{\\mathrm{d}}{\\mathrm{d}t}[b\\dot{p}_1-a\\dot{p}_2]=0\\] 下面是一点对称性的内容。考虑一个依赖一个坐标的系统，其拉氏量为 \\(\\mathcal{L}=\\dot{q}^2/2\\) 现在做一个坐标变换（coordinate transformations）\\(q^\\prime=q+\\delta\\) ，这里的 \\(\\delta\\) 不一定是一个小量只是一个固定的常数，这时我们必然有 \\(\\delta\\mathcal{L}=0\\) ，这就是对称性，更准确的说是空间平移对称性（translation symmetry），这个拉氏量在平移的操作下拉氏量的形式不发生变化。这样的平移对称性如果体现在上面的那个系统中，就相当于如果 \\(q_1^\\prime=q_1+b\\delta\\) 而 \\(q_2^\\prime=q_2-a\\delta\\) 坐标变换，那么就有 \\(\\delta\\mathcal{L}=0\\) 存在。 其它的对称性比如旋转对称性（rotational symmetry）。Susskind 在讨论旋转对称性的时候在笛卡尔坐标系下进行的操作，其实在极坐标下操作是更方便的。旋转对称性对应的是角动量守恒。 对称性和守恒律确实是成双成对出现的。假设坐标及其导数的变化量如下 \\[\\delta q_i=f_i(\\boldsymbol{q})\\delta\\\\ \\delta\\dot{q}_i=\\dot{f_i}(\\boldsymbol{q})\\delta\\] 那么拉氏量的变化量为 \\[\\begin{aligned} \\delta\\mathcal{L}&amp;=\\sum_i\\frac{\\partial\\mathcal{L}}{\\partial q_i}\\delta q_i+\\frac{\\partial\\mathcal{L}}{\\partial\\dot{q}_i}\\delta\\dot{q}_i =\\sum_i\\frac{\\mathrm{d}}{\\mathrm{d}t}\\frac{\\partial\\mathcal{L}}{\\partial \\dot{q}_i}\\delta q_i+p_i\\delta\\dot{q}_i\\\\ &amp;=\\sum_i\\dot{p}_i\\delta q_i+p_i\\delta\\dot{q}_i =\\frac{\\mathrm{d}}{\\mathrm{d}t}\\sum_ip_i\\delta q_i \\end{aligned} \\] 如果这样的坐标变换存在对称性，那么 \\(\\delta\\mathcal{L}=0\\) 成立，这时有 \\[\\begin{aligned}\\frac{\\mathrm{d}}{\\mathrm{d}t}\\sum_ip_i\\delta q_i&amp;=0\\\\ \\frac{\\mathrm{d}}{\\mathrm{d}t}\\sum_ip_if_i(\\boldsymbol{q})&amp;=0\\\\ \\sum_ip_if_i(\\boldsymbol{q})&amp;=\\mathrm{const.} \\end{aligned} \\] 一定有一个对应的守恒律，我们将这个守恒量记为 \\(\\mathcal Q=\\sum_ip_if_i(\\boldsymbol{q})\\) 。 需要注意的是，到目前为止我们还没有涉及到时间依赖的拉氏量，因此在对称性和守恒律中也不会出现时间这个量。我们没有讨论过能量守恒，能量守恒与上述的动量（广义动量）守恒有一点区别。动量守恒与空间对称性相关，而能量守恒与时间对称性相关。 另外物理中存在很多其它类型的对称性，比如镜像对称性等和这里说的对称性是不一样的，它们没有与之对应的守恒律。因为对于镜像对称性有 \\(q\\rightarrow -q\\) 这样的坐标变换的对称，但是这样的对称性并不是累积起来的，考虑对称性的时候应当 \\(q\\rightarrow q+\\delta\\) 并且 \\(\\delta\\) 是一个小量。 当然拉氏量不可能永远像之前描述得一样简单，只包含动能项（以下公式中的 quadratic term in velocity）和势能项，可能还包括如下式第三项的这样的耦合项 \\[\\mathcal{L}=\\sum_{ij}T(\\boldsymbol q)\\dot{q_i}\\dot{q_j}-V(\\boldsymbol q)+\\dot{q}f(\\boldsymbol q)+\\cdots\\] Hamiltonian哈密顿量是能量的更深层次的概念（deeper concept of energy）。 系统的时间平移不变性（time translation invariance）就意味着能量守恒。如果一个系统的拉氏量 \\(\\mathcal{L}(q,\\dot{q},t)\\) 的表达式不显含时间 \\(\\mathcal{L}(q,\\dot{q})\\) ，只隐含时间（该系统的拉氏量会随时间发生变化是因为 \\(\\dot{q}\\) 和 \\(q\\) 是随时间变化），那么这个系统就有时间平移不变性。之前对称性的定义是 \\(\\delta\\mathcal L=0\\) ，但时间平移不变性并不是使 \\(\\delta\\mathcal L= 0\\) 。拉氏量对时间的导数为 \\[\\frac{\\mathrm{d}}{\\mathrm{d}t}\\mathcal{L}(\\boldsymbol{q},\\dot{\\boldsymbol{q}})=\\sum_i\\frac{\\partial\\mathcal{L}}{\\partial q_i}\\dot{q_i}+\\frac{\\partial\\mathcal{L}}{\\partial\\dot{q_i}}\\ddot{q_i} =\\sum_i\\dot{p_i}\\dot{q_i}+p_i\\ddot{q_i}=\\sum_i\\frac{\\mathrm{d}}{\\mathrm d t}p_i\\dot q_i\\\\ \\frac{\\mathrm{d}\\mathcal{L}}{\\mathrm{d}t}-\\frac{\\mathrm{d}}{\\mathrm d t}\\sum_ip_i\\dot q_i=0 \\] 上式中可以明显看到有一个守恒量，哈密顿量定义如下 \\[\\mathcal{H}=\\sum_ip_i\\dot q_i-\\mathcal L \\] 如果拉氏量的形式为 \\(\\mathcal L=m\\dot x^2/2-V(x)\\) ，那么这个系统的哈密顿量为 \\(\\mathcal H=m\\dot x^2/2+V(x)\\) 也就是我们常说的能量 \\(E\\) 。如果拉氏量是显含时间的，那么 \\[\\frac{\\mathrm{d}}{\\mathrm{d}t}\\mathcal{L}(\\boldsymbol{q},\\dot{\\boldsymbol{q}})=\\sum_i\\frac{\\partial\\mathcal{L}}{\\partial q_i}\\dot{q_i}+\\frac{\\partial\\mathcal{L}}{\\partial\\dot{q_i}}\\ddot{q_i} =\\sum_i\\dot{p_i}\\dot{q_i}+p_i\\ddot{q_i}=\\sum_i\\frac{\\mathrm{d}}{\\mathrm d t}p_i\\dot q_i+\\color{red}{\\frac{\\partial\\mathcal L}{\\partial t}}\\\\ \\frac{\\mathrm{d}\\mathcal{L}}{\\mathrm{d}t}-\\frac{\\mathrm{d}}{\\mathrm d t}\\sum_ip_i\\dot q_i=\\color{red}{\\frac{\\partial\\mathcal L}{\\partial t}}\\] 因此这个系统的能量是不守恒的 \\[ \\frac{\\mathrm d\\mathcal H}{\\mathrm dt}=\\color{red}{-\\frac{\\partial\\mathcal L}{\\partial t}}\\] 哈密顿量在量子力学中是一个非常重要的量。 Hamilton’s equations有关微分的一个定理，如果一个全微分可以写为 \\(\\delta F(x,y)=A\\delta x + B\\delta y\\) 这样的形式，那么一定有 \\[\\frac{\\partial F}{\\partial p}=A\\\\ \\frac{\\partial F}{\\partial q}=B\\] 然后哈密顿方程组可以很方便得推导出来 \\[ \\begin{aligned} \\delta\\mathcal H&amp;=\\delta\\sum_i p_i\\dot q_i-\\mathcal L(\\boldsymbol{q},\\dot{\\boldsymbol{q}})\\\\ &amp;=\\sum p_i\\delta q_i+\\dot q_i\\delta p_i-\\frac{\\partial\\mathcal L}{\\partial q_i}\\delta q_i -\\frac{\\partial\\mathcal L}{\\partial \\dot q_i}\\delta \\dot q_i\\\\ &amp;=\\sum\\dot q_i\\delta p_i-\\dot p_i\\delta q_i\\end{aligned}\\] 可以得到哈密顿方程组 \\[\\begin{aligned}\\frac{\\partial\\mathcal H}{\\partial p_i}&amp;=\\dot q_i\\\\ \\frac{\\partial\\mathcal H}{\\partial q_i}&amp;=-\\dot p_i \\end{aligned} \\] Euler-Lagrange 方程和哈密顿方程组是等效的，但是哈密顿方程组是一阶的方程，而 Euler-Lagrange 方程是一个二阶方程。我们也可以从哈密顿方程直接推出能量守恒（略）。 因为哈密顿量是一个守恒量 \\(\\mathcal H(\\boldsymbol p, \\boldsymbol q)=E\\) ，那么在 \\((\\boldsymbol p, \\boldsymbol q)\\) 构成的相空间中，如果有 \\(N\\) 个坐标，那么对应的相空间就有 \\(2N\\) 个维度，而因为确定了系统的能量 \\(E\\) ，因此这个系统在相空间中的轨迹应当被约束在一个 \\(2N-1\\) 维的表面上。 Liouville’s theorem刘维尔定理讨论的是相空间中相点流动的特性（the flow in phase space），把 \\((\\dot{\\boldsymbol p},\\dot{\\boldsymbol{q}})\\) 看作是相空间的一个速度场（flow vector），类似于流体力学中的速度场。在流体力学中，如果一个流体具有不可压缩（incompressible）的性质，那么对应的速度场的散度为零 \\[\\nabla\\cdot\\boldsymbol v=0\\] 相空间中流体的不可压缩性与物理定律的时间反演性质（reversibility）相联系，更加形象的讨论可以直接看 Susskind 教授的视频。由哈密顿方程组可以直接得到系统在相空间中的不可压缩性 \\[ \\begin{aligned} \\frac{\\partial v_p}{\\partial p}+\\frac{\\partial v_q}{\\partial q}=-\\frac{\\partial}{\\partial p}\\frac{\\partial\\mathcal H}{\\partial q}+\\frac{\\partial}{\\partial q}\\frac{\\partial\\mathcal H}{\\partial p}=0 \\end{aligned}\\] 因此可以想象，对于在相空间中的一团流体元，虽然在运动过程中会发生形变，但是它们的体积是不变的，这也就是不可压缩性。比如 damped harmonic oscillator 的哈密顿量（能量）就在逐渐减小，而其在相空间中就体现出可压缩的性质。 Possion bracketsCurly brackets \\[\\left\\{F(\\boldsymbol{p,q}),G(\\boldsymbol{p,q})\\right\\}=\\sum_i\\frac{\\partial F}{\\partial q}\\frac{\\partial G}{\\partial p}-\\frac{\\partial F}{\\partial p}\\frac{\\partial G}{\\partial q}\\] For example, If \\(G(\\boldsymbol{p,q})\\) is the Hamiltonian, then the Possion brackets of \\(F\\) with \\(G\\) is the time derivative of \\(F\\) — the change in \\(F\\) when you change the time in one unit \\(\\varepsilon\\) \\[\\left\\{F,\\mathcal H\\right\\}=\\frac{\\mathrm dF}{\\mathrm dt}=\\frac{\\delta F}{\\varepsilon}\\] Possion brackets is a kind of algebra and has its own rules such as \\[\\begin{aligned}\\left\\{A,B\\right\\}&amp;=-\\left\\{B,A\\right\\}\\\\ \\left\\{AB,C\\right\\}&amp;=A\\left\\{B,C\\right\\}+\\left\\{A,C\\right\\}B\\end{aligned}\\] And there are some special cases \\[\\left\\{q_i,q_j\\right\\}=\\left\\{p_i,p_j\\right\\}=0\\\\ \\left\\{q_i,p_j\\right\\}=\\delta_{ij}\\] For every symmetry, we have a conservation law. We take that thing which is conserved, and we take the possion brackets with this thing, and that gives us the small changes when we make symmetry transformations. The generator for translation is momentum, the generator for time translation is the Hamiltionian, the generator for angular translation is angular momentum. F is a function in phase space and G is for generator. G generates some symmetry. If G is conserved, the Possion brackets of G and Hamiltonian is zero. \\[\\frac{\\mathrm dG}{\\mathrm dt}=\\left\\{G(\\boldsymbol{p,q}),\\mathcal H\\right\\}=-\\left\\{\\mathcal H,G(\\boldsymbol{p,q})\\right\\}=0\\] 泊松括号只是一些 fancy symbols 而已，在处理角动量的时候非常方便，角动量在量子力学中是非常重要的物理量。 EM field唉，这一部分不想写了。 More is different摘自：人民大学的屈帅同学的作业 More is different. Philip W. Anderson 对称性意味着守恒量，该守恒量的观测是受到尺度效应影响的。宏观对称性和微观对称性之间相互独立又相互影响。比如微观对称性就对应着微观尺度上的守恒量，在微观尺度上该守恒量观测影响显著，相应的对称性也就尤为重要。在宏观尺度上，微观量对观测的影响就不是那么显著了，甚至会出现自发对称性破缺，微观守恒量不再影响观测。 这样导致的必然结果就是，宏观系统的演化不严格遵守微观对称性，发生自发对称性破缺。对称性自然而然就有了适用范围，例如 E. Wigner 提出的宇称守恒定律（Parity conservation），就被证实在弱相互作用下由于空间反演对称性破缺，宇称不守恒。 诸如此类还有热力学演化破缺了时间反演对称性，生物大分子破缺了左旋右旋对称性。实际上正是由于对称性破缺，我们的世界才丰富多彩。 不同尺度的问题有着其独特的对称性和复杂性。有着不同的相对理论和相对规律。随着尺度的增加，对称性降低，复杂性升高。在这个过程中，衍生出不同的科学。不同科学之间相互独立又相互交叉，作者想表达量变引起质变，整体与部分之和不同，比如超导、反铁磁、铁电、液晶等新奇物理现象都是由对称性破缺导致的。 粒子物理学家的标准粒子模型和天体物理学家的相对论都是不同尺度上的科学，我们既不能用简单的费曼图描述天体运动，也不能简单地用相对论描述夸克之间的作用。 PS其实当时学得头头是道的，现在也就剩下拉氏量这个概念印象比较深刻了，人类遗忘的速度真的是非常快。","link":"/2020/03/06/Note-on-Classical-Mechanics-by-Leonard-Susskind/"},{"title":"Ways to view pictures via ssh","text":"远程编程的痛点之一是显示图片。 eogeog（Eye of Gnome）和 matplotlib 一样都是使用 X forwarding 把远程服务器上打开的窗口投射到本地，十分卡顿。 imgcatiTerm 提供的 imgcat 是一个更好的选择，也是我过去三年一直在用的，不仅可以在终端展示图片，还可以下载图片到本地。 sshfs今年三月份，基于 Rust 语言开发的 Zed 编辑器正式进入 Beta 阶段，速度之快、体验之好以至于我刚下载它就把仅使用了三个月的 VScode 卸载了。我最期待的 Vim 模式以及 Remote SSH 还正在开发中，为了可以更早的体验它，我甚至可以放弃使用 Vim 一段时间。在尝试寻找暂时的远程开发的替代品的时候，我发现了 sshfs（SSH FileSystem）！ 它可以将远程目录以挂载的形式加载到本地，如果在本地直接进入挂载的目录，也就意味着可以使用 Zed 直接进行编辑。因为 brew 并没有对相关的包进行更新，所以安装教程参考 Install MacFuse and sshfs on macOS Monterey。 因为这涉及到好几个不再更新的包，所以之后不能随便升级系统！静静等待 Zed 开发完善。 一些相关的有用的命令 sshfs jliu@alblas.strw.leidenuniv.nl alblasumount alblas","link":"/2023/05/04/Ways-to-view-pictures-via-ssh/"},{"title":"macOS编程的硬件设置","text":"键位互换用左手小拇指显然更容易够到中英文切换的键位 CapsLock，所以把这个键映射到 Ctrl 上去更方便，具体操作是系统偏好设置-&gt;键盘-&gt;键盘-&gt;修饰键然后进行设置。 加快光标移动速度参考加快macOS的光标移动速度|一日一技，现已将光标速度的配置加入到 .zshrc 中。 编程字体Fira FontsJetBrains MonoCascadia CodeSource Code Pro","link":"/2021/07/01/macOS%E7%BC%96%E7%A8%8B%E7%9A%84%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE/"},{"title":"体验者","text":"我想在一个城市的角落孤独坐着，看人来人往，看忙碌于生活中的众生，有片刻孤独，坐下来，为自己泡一杯茶，为自己按摩一下疲倦的肩膀，跟自己在一起，听自己内在的声音，做自己的朋友，更爱自己一点。 你要足够完整，才能健康地去爱其他人，去照顾和负担其他的人。","link":"/2023/04/07/%E4%BD%93%E9%AA%8C%E8%80%85/"},{"title":"Window Functions in CMB experiments","text":"参考 White &amp; Srednicki 1994 和 Page 2003 文章。在微波背景辐射实验中，最重要的一个仪器参数就是仪器分辨率（beam FWHM），它决定了我们是否能够观测到足够小的尺度，这和宇宙参数限制息息相关，同时微波背景辐射透镜效应的重构也依赖小尺度的信号，分辨率足够高，我们的到的重构结果也能够更好。 Window Function仪器分辨率本质上是一个窗函数的特征尺度，窗函数和真实信号的卷积就是我们观测到的信号，这个过程本质上是一个对真实信号的映射 \\[\\color{black}\\widetilde{T}(\\bm{n})=\\int\\mathrm{d}\\Omega_{\\bm{n}^\\prime}M(\\bm{n}, \\bm{n}^\\prime)T(\\bm{n}^\\prime) \\] 有很多跟仪器相关的效应都可以收入到 mapping function \\(M(\\bm{n}, \\bm{n}^\\prime)\\) 中，比如 beam 效应。有了 mapping function 就可以计算 window function \\(W_\\ell(\\bm{n}, \\bm{n}^\\prime)\\) \\[\\color{black}\\langle\\widetilde{T}(\\bm{n}_1)\\widetilde{T}(\\bm{n}_2)\\rangle=\\frac{1}{4\\pi}\\sum_\\ell(2\\ell+1)C_\\ell W_\\ell (\\bm{n}_1, \\bm{n}_2)\\] 其中 window function 的表达式是 \\[\\color{black}\\small\\begin{aligned} W_\\ell(\\bm{n}_1, \\bm{n}_2) &amp;= \\int\\mathrm{d}\\Omega_{\\bm{n}_1^\\prime}\\int \\mathrm{d}\\Omega_{\\bm{n}_2^\\prime} M(\\bm{n}_1, \\bm{n}_1^\\prime) M(\\bm{n}_2, \\bm{n}_2^\\prime)P_\\ell(\\bm{n}_1^\\prime\\cdot \\bm{n}_2^\\prime) \\\\ &amp;=\\frac{4\\pi}{2\\ell+1}\\sum_m\\int\\mathrm{d}\\Omega_{\\bm{n}_1^\\prime}\\int \\mathrm{d}\\Omega_{\\bm{n}_2^\\prime} M(\\bm{n}_1, \\bm{n}_1^\\prime) M(\\bm{n}_2, \\bm{n}_2^\\prime)Y_\\ell^m(\\bm{n}_1^\\prime)Y_\\ell^{m*}(\\bm{n}_2^\\prime)\\\\ &amp;=\\frac{4\\pi}{2\\ell+1}\\sum_m\\int\\mathrm{d}\\Omega_{\\bm{n}_1^\\prime} M(\\bm{n}_1, \\bm{n}_1^\\prime)Y_\\ell^{m*}(\\bm{n}_1^\\prime)\\int \\mathrm{d}\\Omega_{\\bm{n}_2^\\prime} M(\\bm{n}_2, \\bm{n}_2^\\prime)Y_\\ell^m(\\bm{n}_2^\\prime) \\end{aligned}\\] 一般来说，窗函数的映射 \\(M(\\bm{n}, \\bm{n}^\\prime)\\) 在全天都是一样的，不依赖于 \\(\\bm n\\) ，只依赖于 \\(\\bm{n}^\\prime - \\bm{n}\\)，也就是上面的积分跟 \\(\\bm{n}_1\\) 和 \\(\\bm{n}_2\\) 无关。所以上面的式子可以简化为 \\[\\color{black}\\begin{aligned} W_\\ell(\\bm{n}, \\bm{n}) &amp;= \\frac{4\\pi}{2\\ell+1}\\sum_m\\left|M_{\\ell m}\\right|^2 \\end{aligned}\\] 之后把 \\(W_\\ell(\\bm{n}, \\bm{n})\\) 简单记为 \\(W_\\ell\\) 。 Beam Profile最简单的情况是 symmetric beam ，也就是 \\(\\color{black}b(\\bm{n}, \\bm{n}^\\prime)\\) 只依赖 \\(\\color{black}\\bm{n}\\cdot\\bm{n}^\\prime\\)，此时 \\(\\color{black}b(\\bm{n}, \\bm{n}^\\prime)\\) 可以写成 \\(\\color{black}b^S(\\theta)\\)，展开成勒让德级数 \\[\\color{black}b^S(\\theta)=\\frac{1}{4\\pi}\\sum_\\ell (2\\ell+1)b_\\ell P_\\ell(\\cos\\theta)\\] 然后利用球谐函数的 addition theorem 和 orthogonality 可以毫不费力地证明 \\[\\color{black}W_\\ell=b_\\ell^2\\] 可以用 healpy.beam2cl 把任意的对称的 \\(\\color{black}b^S(\\theta)\\) 转换成 \\(\\color{black}b_\\ell\\) 函数，beam asymmetry 更加复杂，这里不讨论。 Gaussian Beam Profile参考 White 1992 文章。一个高斯的 beam 有 \\[\\color{black}b^S(\\theta)=\\frac{1}{2\\pi\\sigma^2}\\exp\\left[-\\frac{\\theta^2}{2\\sigma^2}\\right]\\] 一般来说我们有 \\(\\sigma\\ll1\\)，利用勒让德多项式的正交性质，可得 \\[\\color{black}\\begin{aligned}b_\\ell&amp;=2\\pi\\int b^S(\\theta)P_\\ell(\\cos\\theta)\\mathrm{d}\\theta \\\\ &amp;= \\frac{1}{\\sigma^2}\\int_0^\\pi \\exp\\left[-\\frac{\\theta^2}{2\\sigma^2}\\right]P_\\ell(\\cos\\theta)\\mathrm{d}\\theta \\\\ &amp;= \\frac{1}{\\sigma^2}\\int_0^\\infty e^{-x}P_\\ell(1-\\sigma^2x)\\mathrm{d}x\\end{aligned}\\] 中间做了一个替换 \\(x=\\theta^2/2\\sigma^2\\)，积分上限原则上应该使勒让德多项式里的自变量大于负一，这里忽略这一点，因为积分在 \\(\\theta\\) 非常小的时候就已经收敛了，后续贡献的微不足道。上式的积分可以展开为 \\[\\color{black}\\begin{aligned}\\int_0^\\infty\\mathrm{d}x\\ e^{-x}P_\\ell(1-\\sigma^2 x) &amp;= \\int_0^\\infty\\mathrm{d}x\\ e^{-x} \\sum_{n=0}^\\infty \\frac{1}{n!}(-\\sigma^2x)^nP_\\ell^{(n)}(1) \\\\ &amp;=\\sum_{n=0}^\\infty\\frac{1}{n!}(-\\sigma^2)^nP_\\ell^{(n)}(1)\\int_0^\\infty\\mathrm{d}x\\ e^{-x}x^n \\end{aligned}\\] 利用 \\[\\color{black}\\int_0^\\infty e^{-x}x^n=n!\\] 可以得到 \\[\\color{black}\\begin{aligned}\\int_0^\\infty\\mathrm{d}x\\ e^{-x}P_\\ell(1-\\sigma^2 x) &amp;= \\sum_{n=0}^\\infty(-\\sigma^2)^nP_\\ell^{(n)}(1) \\end{aligned}\\] 下面手动求一下 \\(P_\\ell^{(n)}(1)\\)，采用勒让德函数的其中一种表达式 \\[\\color{black} P_\\ell(x)=\\sum_{k=0}^\\ell\\begin{pmatrix}\\ell \\\\ k\\end{pmatrix} \\begin{pmatrix}\\ell+k \\\\ k\\end{pmatrix} \\left(\\frac{x-1}{2}\\right)^k \\] 如果对上式求 \\(n\\) 阶导，并在 \\(x=1\\) 处取值，那么只会剩下 \\(k=n\\) 的一项，且当 \\(n&gt;\\ell\\) 的时候，导数为零 \\[\\color{black}P^{(n)}_\\ell(x)=\\frac{1}{2^n n!}\\frac{(\\ell+n)!}{(\\ell-n)!} \\] 代入上面的积分，得到 \\[\\color{black}\\begin{aligned}\\int_0^\\infty\\mathrm{d}x\\ e^{-x}P_\\ell(1-\\sigma^2 x) &amp;= \\sum_{n=0}^\\ell(-\\sigma^2)^n\\frac{1}{2^n n!}\\frac{(\\ell+n)!}{(\\ell-n)!} \\end{aligned}\\] 有近似（不证明了） \\[\\color{black}\\frac{(\\ell+n)!}{(\\ell-n)!}\\approx[\\ell(\\ell+1)]^n\\approx\\left(\\ell+\\frac{1}{2}\\right)^{2n}\\] 这两个近似是同等程度的近似，一般采用第一个近似，最后我们得到 \\[\\color{black}\\begin{aligned}\\int_0^\\infty\\mathrm{d}x\\ e^{-x}P_\\ell(1-\\sigma^2 x) &amp;= \\sum_{n=0}^\\ell(-\\sigma^2)^n\\frac{1}{2^n n!}[\\ell(\\ell+1)]^n\\\\ &amp;=\\exp\\left[-\\frac{1}{2}\\ell(\\ell+1)\\sigma^2\\right] \\end{aligned}\\] 所以我们得到 \\[\\color{black}b_\\ell=\\frac{1}{\\sigma^2}\\exp\\left[-\\frac{1}{2}\\ell(\\ell+1)\\sigma^2\\right]\\] 但通常还存在一个利用 dipole 校准的过程，使得 \\(b_{\\ell=1}=1\\) 所以，最后得到的 Gaussian symmetric beam 的结果是 \\[\\color{midnightblue}b_\\ell=\\exp\\left[-\\frac{\\ell(\\ell+1)}{2}\\sigma^2\\right]\\] 下面是一个针对自旋的修正 \\[\\color{midnightblue}b_\\ell=\\exp\\left[-\\frac{\\ell(\\ell+1) - s^2}{2}\\sigma^2\\right]\\] 这个近似在 \\(\\sigma&lt;0.1\\) 的范围内都非常准确，这包括了现在所有的实验的分辨率。可以用 healpy.gauss_beam 获取 Gaussian beam 的 \\(b_\\ell\\) 函数。 Pixel Window Function参考 HEALPix Primer 的附录。实际上像素化也是一种窗函数，只是这个窗函数是 Top-Hat 的，并不是高斯的，可以用 healpy.pixwin 获取 \\(p_\\ell\\) 函数。","link":"/2021/11/26/Window-Functions-in-CMB-experiments/"},{"title":"后学生时代","text":"「我不后悔，但人生难免会有遗憾。」","link":"/2022/07/14/%E5%90%8E%E5%AD%A6%E7%94%9F%E6%97%B6%E4%BB%A3/"},{"title":"如何进行文献管理？","text":"最适合自己的才是最好的。之前使用过 SnowyOwl 和 ReadCube 等文献管理软件，总是有不尽如人意的地方。后来发现一个大佬居然使用最原始的终端管理文献，决定效仿一下。然而直接利用终端和文件夹管理文献有一个弊端在于文件名是不能直接显示文献信息的，我发现这一缺陷可以利用元数据（Metadata）解决。 可以用于修改 PDF 元数据的工具有 ExifTool 和 PDFTK ，其中 ExifTool 语法简单且一直在进行更新，决定采用它。 使用 brew install exiftool 下载它。一些参考资料： ExifTool 完全入门指南ExifTool TagNamesExifTool Forum 一些常用的 exiftool 命令： # 读取所有元数据exiftool paper.pdf# 为文件修改或者添加作者和标题exiftool -author='xxx' -title='xxx' -overwrite_original pp.pdf# 写入当前目录下所有文件exiftool -author='xxx' -overwrite_original ./# 写入当前目录和子目录下的所有文件exiftool -author='xxx' -overwrite_original ./ -r# 修改文件创建时间，可对应文章发布时间exiftool -createdate='1997:07:16 00:00:00' -overwrite_original pp.pdf 为了方便进行文献检索，我另外写了两个脚本 lspaper 和 fdpaper 分别用于列出文章信息以及搜索文章，在我的 .config 仓库中。 目前为止，唯一的缺点是需要自己录入文章的标题、作者等信息，有些杂志比如 A&amp;A 会自带这些关键信息，但大部分杂志没有这样的自觉。","link":"/2021/11/11/%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%96%87%E7%8C%AE%E7%AE%A1%E7%90%86%EF%BC%9F/"},{"title":"山顶","text":"不用爬到山顶，也能看到好风景。","link":"/2024/06/20/%E5%B1%B1%E9%A1%B6/"},{"title":"简单计算集群的搭建","text":"这是北师大理论宇宙学课题组的小型计算集群的使用说明以及搭建过程。 使用计算集群分为普通用户的使用和管理者的使用。 普通用户 三个主机分别是novamaria、vivy和diva，需要使用校园网登录。三台主机之间互相知道对方的主机名，如果你已经登录到novamaria上，可以直接通过ssh diva或者ssh vivy访问另外两台主机。 修改密码需要在三台主机上都进行修改。 三个主机的用户目录/home内容一致，在novamaria上编辑的脚本，在vivy上也能看到，普通用户只需要选择一个计算资源宽裕的主机进行计算。 文件夹/data是用来存放大型数据的（比如模拟等），程序脚本可以存放到各自用户目录下，/data文件夹一共44T的存储空间，存放数据的时候注意用df -h查看还有多少余量，不要超过存储上限，不然别人的数据就被覆盖了。 在/share文件夹里有常用的公共资源，比如Anaconda3和Anaconda2的安装包等。如果对共享资源有别的需要可以直接提意见。 如需连网可以使用深澜命令行客户端登录校园网关，在/share里也有资源。 服务器大家一起共享，请大家为其它跑程序的同学考虑一下！一个用户最多占用所有计算资源的70%，也就是占满两台服务器左右，发现非法占用直接杀死进程，如果要跑大型并行程序，到vivy和diva上跑，因为novamaria是集群主节点，很多数据传输的工作在此服务器上进行，跑满的话所有/home下的操作都会变慢。 有需要用sudo安装的包软件，直接提意见。 管理者新建用户 因为没有NIS服务，所以创建新用户的时候需要在三个节点上都创建用户，具体操作 sudo adduser foo # 在三个主机上都新建同样的用户并查看UID和GID是否一致sudo mkdir /data/foo # 新建一个属于该用户存储数据的目录chown foo /data/foo # 修改权限chgrp foo /data/foo # 修改权限 删除用户 sudo deluser foosudo rm -rf /data/foo 需要注意的是useradd和adduser并不一样，userdel和deluser并不一样。 搭建计算集群搭建小组成员：刘晋弋，申嵩聿，王正一，韩嘉康，李竹海，贾涵筇，胡老师服务器放置地点：科技楼A229小黑屋 三台服务器是一模一样的机型和配置，每个服务器有58个核，1T的固态硬盘和4T的机械硬盘，非常适合搭建计算集群。 TODO 在这里/etc/update-motd.d更改欢迎语 调整风扇转速，风扇转速上限解锁 免VPN校外登录 听说有一个只能在自己目录下面sudo的东西 准备工作硬件准备 插线板千兆交换机显示器键盘五类网线四根Ubuntu Desktop 18.04 LTS启动盘 系统重装 使用Ubuntu Desktop 18.04 LTS启动U盘重装系统。如果存在硬盘清理不干净的情况，可以使用Security Erase来清理所有固态和机械（耗时较长），再进行安装系统的过程。三台服务器健康状况良好。 网络配置服务器之间使用千兆交换机连接（最大传输速度为125 Mb/s），所有服务器在校园网内随意连接。 Hostname IP novamaria xx.xx.xx.133 vivy xx.xx.xx.60 diva xx.xx.xx.201 需要注意的是，尽量使用独立网卡，使用ifconfig可以查看有几个网卡，独立网卡名称开头是enp，集成网卡名称开头是eno。 服务器最好使用静态IP（Static IP）而不是动态IP（DHCP），但是因为在校园网内部IP和网卡MAC是绑定的，IP够用的情况下不会出现IP被占用的情况，所以这里不进行设置，如果因为机器重启导致IP发生变化，直接修改机器配置即可。 软件安装下面是一些之后需要用到的软件，先提前安装好 $ sudo apt-get update$ sudo apt-get installopenssh-client openssh-server \\vsftpd \\net-tools xfsprogs lvm2 \\nfs-server nfs-client rpcbind glusterfs-server glusterfs-client \\git \\vim neovim python-neovim python3-neovim python3-pip \\gfortran build-essential golang nodejs php \\cmake automake pkg-config autoconf libtool \\lsscsi inxi \\curl zsh tmux ranger tree htop screen \\msttcorefonts \\libncurses5-dev libssl-dev zlib1g-dev \\ SSH这一步使得三台服务器之间能够通过主机名直接访问，在/etc/hosts中添加 /etc/hosts# IP Hostnamexx.xx.xx.133 novamariaxx.xx.xx.60 vivyxx.xx.xx.201 diva 之后我们将novamaria称为主节点，作为各项服务的服务端，其它两个主机作客户端。如果需要进一步配置免密访问，可以先用ssh-keygen生成密钥和公钥，然后再ssh-copy-id将公钥复制到另外两台服务器上。 NFS网络文件系统（Network File System）是用来在不同主机之间共享文件的，参考了How To Set Up an NFS Mount on Ubuntu 18.04和 Linux下配置NIS和NFS /home目录。 这里主要说明如何实现/home文件夹的NFS部署过程。后续可以在vivy上部署/opt文件夹用来共享一些比如OneAPI之类的计算包，也可以在diva上部署/share文件夹用来存放公共资源，更好地利用三个服务器的固态。 NFS服务端在novamaria上编辑/etc/exports文件，添加下面两行 /etc/exports/home xx.xx.xx.60/24(insecure,rw,sync,no_root_squash,no_subtree_check)/home xx.xx.xx.201/24(insecure,rw,sync,no_root_squash,no_subtree_check) 然后sudo exportfs -a，重启NFS服务 sudo service nfs-kernel-server restart NFS客户端先将原来的/home进行备份（放置后续操作失误），在vivy和diva上编辑/etc/fstab文件，添加下面一行就可以重启进行挂载 novamaria:/home /home nfs noatime,noauto,x-systemd.automount,x-systemd.device-timeout=10s 0 2 最后需要重启服务端和客户端。 GlusterFSGlusterFS是分布式文件存储系统。首先将每个计算节点上的四块机械硬盘整合到一个逻辑卷中（如何在Linux中创建/配置LVM），可以通过lsblk查看未挂载的机械硬盘的设备名，确认需要纳入逻辑卷中的设备名 sudo pvcreate /dev/sda /dev/sdb /dev/sdc /dev/sdd # create physical volumnsudo pvs # display physical volumnsudo vgcreate vg /dev/sda /dev/sdb /dev/sdc /dev/sdd # create volumn groupsudo vgs vg # display volumn gruopsudo lvcreate -n lva -l 100%FREE vg # create logical volumnsudo lvs /dev/vg/lva # display logical volumnsudo mkfs -t xfs /dev/vg/lva # 格式化逻辑卷sudo mkdir -p /glusterfs # 创建要挂载的目录sudo mount /dev/vg/lva /glusterfs # 挂载 然后在/etc/fstab里添加 /etc/fstab/dev/vg/lva /glusterfs xfs defaults 0 0 当每个计算节点上4块机械都整合到一个逻辑卷中之后，进行GlusterFS的搭建（如何在Ubuntu 18.04上使用GlusterFS设置高可用性存储），首先在每个节点上启动并查看GlusterFS的状态 sudo systemctl start glusterdsudo systemctl enable glusterdsudo systemctl status glusterd 在主节点novamaria上配置信任池 sudo gluster peer probe vivysudo gluster peer probe divasudo gluster peer status 此时信任池是空的，创建完之后可以在vivy或者diva上查看信任池状态。在novamaria上创建卷 sudo gluster volume create gfsv transport tcp {novamaria,vivy,diva}:/glusterfs/brick gfsv是GFS Volume的缩写，这里需要注意我们不需要进行备份，在创建卷的时候没必要加上replica这个参数。查看卷的信息，启动卷 sudo gluster volume infosudo gluster volume start gfsv 然后在主节点novamaria进行挂载，机械硬盘主要用于存储数据所以命名为/data sudo mkdir /datasudo mount -t glusterfs novamaria:/gfsv /data 在diva和vivy中的/etc/fstab文件里添加下面这一行（NFS） /etc/fstabnovamaria:/gfsv /data glusterfs defaults,_netdev 0 0 可以使用df -h查看GlusterFS在novamaria上的挂载情况。 /data 平均读出速度达到220M/s，平均写入速度达到100M/s，对比之下非分布式的系统（也就是在同一个主机内进行读写操作）可以达到的读写速度分别是330M/s和180M/s，而远程文件系统（通过网线进行传输）受限于网卡、交换机的带宽，仅能达到读写速度110M/s和50M/s，GlusterFS总体而言是它们的平均值，也可以看到分布式存储的特点。 失败的NIS网络信息服务（Network Infomation Service）提供共享用户信息，一个用户在Server上可以登录，那么在Client上也能登录，共享了用户、群组的信息。配置分为Server端和Client端。参考这些资源 NIS Installation and Configuration[How-To] Automounting Home Directories with NIS and NFSnstalling NIS server on Ubuntu 18.04 LTS总结下最近建立集群的步骤以及NIS服务器搭建 因为有严重的BUG没有解决，做完NIS之后Client端登录会明显变慢，最终并未做成 NIS 服务！","link":"/2021/07/19/%E7%AE%80%E5%8D%95%E8%AE%A1%E7%AE%97%E9%9B%86%E7%BE%A4%E7%9A%84%E6%90%AD%E5%BB%BA/"},{"title":"配置Linux新账户","text":"如果有了一个新的服务器账号，按下面的顺序进行操作。 SSH配置 ssh 免密登录，在本地配置 ssh-keygen -t rsa # 生成本地的密钥和公钥匙ssh-copy-id foo@xx.xx.xx.xx # 将本地的公钥拷贝到服务器上 在本地编辑~/.ssh/config文件配置服务器的信息 Host FOOHostName xx.xx.xx.xxUser fooIdentitiesOnly yes 在本地测试是否能通过ssh FOO免密登录。 Zsh使用cat /etc/shells查看当前可以使用的shell，如果有/bin/zsh的一行，可以直接配置 chsh -s /bin/zsh 如果服务器用了NIS系统，需要用ypchsh来更改shell。重新登录会有一个简单的Zsh配置过程。然后我们需要安装Oh My Zsh来增强Zsh的功能，这样安装 sh -c &quot;$(wget https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)&quot; 注意，有些Oh My Zsh的主题需要取消conda默认的环境才能正确的显示 conda config --set changeps1 False Git配置git全局的用户名和邮箱 git config user.name &quot;Jinyi Liu&quot;git config user.email &quot;liujy0129@gmail.com&quot; 使用SSH中生成密钥公钥的命令，在服务器上生成密钥和公钥并将公钥拷贝到我的GitHub仓库里。 Anaconda从清华镜像下载Anaconda3并安装 wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-5.3.1-Linux-x86_64.shbash Anaconda3-5.3.1-Linux-x86_64.sh 可以将上面的Anaconda3链接换成最新的版本，然后安装一些必需的包 pip3 install pynvimconda install numpy matplotlib scipy ipython htop 需要将tornado的版本回退（参考 Jupyter-notebook Issue #4630） conda install tornado==5.1.1 如果需要建立一个Jupyter notebook服务器，可以参考如何访问服务器的Jupyter notebook。 克隆配置文件从我的GitHub主页上克隆config这个仓库，并进行一些安装和替换。 依赖安装NodeJs是NeoVim的依赖。","link":"/2020/04/03/%E9%85%8D%E7%BD%AELinux%E6%96%B0%E8%B4%A6%E6%88%B7/"},{"title":"Fundamentals of Radio Interferometry","text":"Notes from 18th Synthesis Imaging Workshop 2022. Rick Perley’s lectures are fantastic! Fundamentals of Radio Interferometry Radio Interferometry – Advanced Topics Basic Radio Interferometry – Geometry Most basic interferometerHere we have two perfect sensors. Vector \\(\\bm b\\) is baseline vector and \\(\\bm s\\) is the source direction. The geometric time delay is thus \\[\\color{black}\\tau_g=\\bm b \\cdot \\bm s / c\\] which notes the time difference between these two sensors when light arrives. The sensor senses the Electric field and convert it to voltage variation. \\[\\color{black}\\begin{aligned} V_1&amp;=E\\cos[\\omega(t-\\tau_g)] \\\\ V_2&amp;=E\\cos(\\omega t) \\end{aligned}\\] Then these two signals enter into a correlator which does a simple multiplication \\[\\color{black}V_1 V_2 = P[\\cos(\\omega \\tau_g) + \\cos(2\\omega t - \\omega\\tau_g) ] \\] where \\(\\color{black}P\\) is the power equals to \\(\\color{black}E^2/2\\). It is clearly shown that the second term of the right hand side is a rapidly varying term while the first term is unchaning with time. The cosine response is then the time average of this multiplication \\[\\color{black}R_c=P\\cos(\\omega\\tau_g) \\] This response is only dependent on the geometric time delay. And if given the fixed length of baseline, \\(\\color{black}R_c\\) only has an angle dependance. We can generate sine response by inserting a 90 degree phase shift in one of the signal paths. \\[\\color{black}R_s=P\\cos(\\omega\\tau_g) \\] It should be pointed out that the sensor doesn’t know where is the light coming from. The sensor retains the Electric fields from all directions. So the actual signal we would expect from the most basic inteferometer is an integral over the solid angle \\[\\color{black}\\begin{aligned} R_c&amp;=\\int I(\\bm s)\\cos(\\omega\\tau_g)\\mathrm{d}\\Omega \\\\ R_s&amp;=\\int I(\\bm s)\\sin(\\omega\\tau_g)\\mathrm{d}\\Omega \\end{aligned}\\] where \\(\\color{black} R_c\\) and \\(\\color{black} R_s\\) record the even and odd components of the brightness function \\(\\color{black} I(\\bm s)\\) respectively. That is all we need to recover the brightness distribution on the sky. Complex visibilitiesNow we DEFINE the complex visibilites \\(\\color{black}V\\) out of the independent real outputs \\(\\color{black} R_c\\) and \\(\\color{black} R_s\\) as \\[\\color{blue}V_\\nu(\\bm{b})=R_c-iR_s=\\int I_\\nu(\\bm s)e^{-2\\pi i \\nu\\bm{b}\\cdot\\bm{s}/c}\\mathrm{d}\\Omega \\] where I replace the angular frequency \\(\\color{black} \\omega\\) with frequency \\(\\color{black}\\nu\\). A further simplication is to express the baseline vector as \\(\\color{black}(u\\lambda, v\\lambda)\\), in the unit of wavelength and the source direction as direction cosines \\(\\color{black}(l,m)\\), then we have \\[\\color{green}V_\\nu(u,v)\\color{black}=\\int I_\\nu(l,m)e^{-2\\pi i (ul+vm)}\\mathrm{d}\\Omega \\] More praticalInclude various pratical details. Antenna response\\[\\color{black}V_\\nu(\\bm{b})=\\int \\color{red}{A_1(\\bm s)A_2^*(\\bm s)}\\color{black}I_\\nu(\\bm s)e^{-2\\pi i \\nu\\bm{b}\\cdot\\bm{s}/c}\\mathrm{d}\\Omega \\] Finite Bandwidth\\[\\color{black}V(\\bm{b})=\\int I_\\nu(\\bm s)\\color{red}{\\mathrm{sinc}(\\tau_g\\Delta\\nu)}\\color{black}e^{-2\\pi i \\nu_0\\bm{b}\\cdot\\bm{s}/c}\\mathrm{d}\\Omega \\] You need delay tracking to track the source and keep it in between the two nulls in the fringe pattern. finite_bw.pyx = np.linspace(-30,30,1000) # arcminus = np.linspace(450,550,3) # u = Baseline/LambdaRC = lambda u: np.cos(2*np.pi*u*np.sin(x*np.pi/180/60)) # R_c = Pcos(2pi*ul)RC_sum = 0.fig, ax = plt.subplots()for u in us: RCu = RC(u) ax.plot(x, RCu, lw=0.4) RC_sum += RCuax.plot(x, RC_sum/len(us), c='black', lw=3)ax.hlines(0., x.min(), x.max(), color='black', lw=1)ax.set_xlabel('Offsets from Meridian (arcmin)')ax.set_ylabel('Cosine Response')ax.set_xlim([x.min(), x.max()])fig.show() 对任意一个基线来说，它只能在垂直与基线方向的那个方向获得最大的响应，也就是子午线上。因此对所有基线求和之后，只有天顶附近的一块很小的区域能获得比较高的响应，也就是所有基线子午线相交之处（忽略基线的三维分布）。 Source motionThe source is moving through the interferometer fringe pattern and the natural finge rate is about \\(\\color{black}v_f=u\\omega_e\\cos\\delta\\). Add phase shift to avoid the source from falling into the negative or zero response. Finite time averagingThe reason is that the fringe tracking mechanism is correct for only one point in the sky. All others have a different rate. 对于 VLA 的 A configuration 来说，照相的积分时间不能超过 10 秒，这一点上和其它波段的观测区别很大，甚至是难以想象的，因为一般而言我们只要能够积分到足够多的时间，一个源的细节就越能被捕捉到。 Frequency DownconversionHigh frequency components are much more expensive, and generally perform more poorly than low frequency components. Most radio interferometers use down conversion to translate the radio frequency information from the ‘RF’ to a lower frequency band. Geometry2-D InterferometersInterferometers of which the baselines lie on a plane over time (earth rotation), for example all E-W interferometers or any 2-D array at a single instance of time can use the 2-D geometry. In both of these scenarios, accurate 2-D Fourier transform could be applied. \\[ \\color{black} I_\\nu(l,m)=\\int V_\\nu(u,v)e^{2\\pi i (ul+vm)} \\mathrm{d}u\\mathrm{d}v \\] Imaging does this inversion. 3-D InterferometersThe complete relation between the visibility and sky brightness is now more complicated. \\[\\color{black} V_\\nu(u,v,w)=\\int I_\\nu(l,m)e^{-2\\pi i (ul+vm+wn)}\\mathrm{d}l\\mathrm{d}m \\] 💡Note that this is neither a 2-D or 3-D Fourier transform.If we introduce phase tracking such that the phases are adjusted by \\(e^{2\\pi i w}\\) and remembering that \\(\\color{black}l^2+m^2+n^2=1 \\) we get \\[\\color{black}V_\\nu(u,v,w)=\\int I_\\nu(l,m)e^{-2\\pi i[ul+vm+w(\\sqrt{1-l^2-m^2}-1)]}\\mathrm{d}l\\mathrm{d}m\\] If the term \\(\\color{black}w(\\sqrt{1-l^2-m^2}-1)\\ll1\\) is very small, then we can ignore it and return to a nice 2-D Fourier transform. Noting that \\(\\color{black}w&lt;b/\\lambda\\) as a coordinate component of baseline vector \\(\\color{black}\\bm b\\) and if \\(\\color{black}l^2+m^2=\\theta^2\\ll1 \\), one can write the condition for effective coplanarity as \\[\\color{black} \\begin{aligned} \\frac{b}{\\lambda}(1-\\sqrt{1-\\theta^2})&amp;\\ll1 \\\\ 1-\\sqrt{1-\\theta^2}&amp;\\ll\\frac{\\lambda}{b} \\\\ \\frac{1}{2}\\theta^2&amp;\\ll\\frac{\\lambda}{b} \\\\ \\theta_\\mathrm{max}&amp;\\ll\\sqrt{2\\theta_\\mathrm{syn}} \\end{aligned} \\] where \\(\\color{black} \\theta_\\mathrm{syn}\\) is defined as the angular seperation between lobs \\(\\color{black}\\lambda/b\\). The above relation means that the main lob should include the FOV very well such we can approximate the 3-D interferometer to a 2-D one. A further approximation is \\(\\color{black}\\theta_\\mathrm{max}\\sim\\lambda/D \\) – the maximum angle for imaging is limited by the primary beam. Then we get the criterion \\[\\color{black}\\frac{\\lambda b}{D^2}&gt;1 \\] UV coverageEach base line traces out an ellipse in UV plane over 24 hours \\[\\color{black} u^2 + \\left( \\frac{v-B_z\\cos\\delta_0}{\\sin\\delta_0} \\right)^2=B_y^2+B_z^2 \\]","link":"/2022/11/11/Fundamentals-of-Radio-Interferometry/"}],"tags":[{"name":"CMB","slug":"CMB","link":"/tags/CMB/"},{"name":"RadioAstro","slug":"RadioAstro","link":"/tags/RadioAstro/"},{"name":"SIW2022","slug":"SIW2022","link":"/tags/SIW2022/"},{"name":"Physics","slug":"Physics","link":"/tags/Physics/"},{"name":"AST9240","slug":"AST9240","link":"/tags/AST9240/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"WeakLensing","slug":"WeakLensing","link":"/tags/WeakLensing/"},{"name":"math","slug":"math","link":"/tags/math/"},{"name":"mac","slug":"mac","link":"/tags/mac/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"vim","slug":"vim","link":"/tags/vim/"},{"name":"Life","slug":"Life","link":"/tags/Life/"},{"name":"bnu","slug":"bnu","link":"/tags/bnu/"}],"categories":[],"pages":[{"title":"About","text":"","link":"/about/index.html"}]}